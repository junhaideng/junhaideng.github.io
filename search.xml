<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>负载均衡</title>
    <url>/2021/11/10/alg/load-balance/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在实际生产过程中，我们往往会通过集群的方式部署服务器，而不是单机部署，从而可以提高服务的并发能力。</p>
<p>但是这样部署产生了一个新的问题：如何决定某个请求发往的服务器？这就是负载均衡算法所需要解决的问题。</p>
<span id="more"></span>

<img src="1.svg" width=400>


<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>目前比较常见的负载均衡算法有：</p>
<ul>
<li>轮询法 (Round Robin)</li>
<li>随机法 (Random)</li>
<li>权重轮询</li>
<li>权重随机</li>
<li>哈希法</li>
<li>最小响应时间</li>
<li>最小连接</li>
</ul>
<p>下面一一进行介绍</p>
<blockquote>
<p>注意：为了简单，下面的代码未考虑并发，仅提供算法思路</p>
</blockquote>
<h4 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h4><p>轮询法属于最简单的负载均衡策略之一，它的意思是说，这一次请求选择的是 A 服务器，那么下一次请求我们就选择 A 后面的服务器，依次类推，到达最后一个位置之后，重新选择第一个服务器。</p>
<img src="2.svg" width=200>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RoundRobin</span><span class="params">(servers []<span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  	<span class="comment">// 保存访问位置</span></span><br><span class="line">	pos := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		res := servers[pos]</span><br><span class="line">    	<span class="comment">// 移动一个位置，下一次选择这个</span></span><br><span class="line">		pos++</span><br><span class="line">        <span class="comment">// 如果达到最后一个</span></span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(servers)&#123;</span><br><span class="line">          pos = <span class="number">0</span> </span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>通过生成随机数，从而选择对应的服务器，算法十分简单</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 随机数种子初始化</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Random</span><span class="params">(servers []<span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">	index := rand.Intn(<span class="built_in">len</span>(servers))</span><br><span class="line">	<span class="keyword">return</span> servers[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="权重轮询"><a href="#权重轮询" class="headerlink" title="权重轮询"></a>权重轮询</h4><p>在部署服务的时候，有些服务器可能性能好一点，有些服务器呢，性能差一点，这样的话，如果所有服务器平摊全部请求，肯定不好，那么我们可以给每一个服务器设置一个权重，权重越大，表示性能越好，可以接受更多的服务。比如说现在有两台服务器，A 服务器权重为 <code>3</code>，B 服务器权重为 <code>1</code>，那么平均下来，A 服务器应该接受 <code>3/4</code> 的请求，而B服务器接受 <code>1/4</code> 的请求。</p>
<p>一种很简单的思路就是将所有的服务器按照权重平铺延展，类似下图，然后使用轮询的方式</p>
<img src="3.svg" width=200>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	ip     <span class="type">string</span></span><br><span class="line">	weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WeigthRoundRobin</span><span class="params">(servers []Server)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	pos := <span class="number">0</span></span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(servers))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; servers[i].weight; j++ &#123;</span><br><span class="line">			s = <span class="built_in">append</span>(s, servers[i].ip)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		res := s[pos]</span><br><span class="line">		pos++</span><br><span class="line">		<span class="keyword">if</span> pos == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">			pos = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种算法有所缺陷，那就是不平滑，在一个时间段中可能只有 A 服务器在用，但是 B 服务器可能都没有接收到任何请求，针对这种情况，出现了一种比较平滑的算法，<code>nginx</code> 中的权重轮询就是该类。该算法的思想是：</p>
<ul>
<li>服务器的初始权重(<code>current</code>)为0，有效权重(<code>effective</code>)为设置的权重值，计算所有的权重和为 <code>total</code></li>
<li>每一轮选择中，将当前的权重+有效权重，current 最大的为本次选中的服务器</li>
<li>选中该服务器之后，<code>current</code> 需要减去 <code>total</code></li>
<li>进行下一轮</li>
</ul>
<p>下面是权重为 <code>3</code> 的服务器 A 和权重为 <code>1</code> 的服务器 B 执行该算法的一整轮过程</p>
<table>
<thead>
<tr>
<th align="center">请求次数</th>
<th align="center">current</th>
<th align="center">添加 effective 后</th>
<th align="center">total</th>
<th align="center">选中</th>
<th align="center">选中后 current</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[0, 0]</td>
<td align="center">[3, 1]</td>
<td align="center">4</td>
<td align="center">A</td>
<td align="center">[-1, 1]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[-1, 1]</td>
<td align="center">[2, 2]</td>
<td align="center">4</td>
<td align="center">A</td>
<td align="center">[-2, 2]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[-2, 2]</td>
<td align="center">[1, 3]</td>
<td align="center">4</td>
<td align="center">B</td>
<td align="center">[1, -1]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[1, -1]</td>
<td align="center">[4, 0]</td>
<td align="center">4</td>
<td align="center">A</td>
<td align="center">[0, 0]</td>
</tr>
</tbody></table>
<p>代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SmoothWeightRoundRobin</span><span class="params">(servers []Server)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	current := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(servers))</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">		total += servers[i].weight</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		max := <span class="number">0</span></span><br><span class="line">		index := <span class="number">0</span></span><br><span class="line">		<span class="comment">// 加入 effective 权重</span></span><br><span class="line">		<span class="comment">// 并且找到 current 权重最大的</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">			current[i] += servers[i].weight</span><br><span class="line">			<span class="keyword">if</span> current[i] &gt; max &#123;</span><br><span class="line">				max = current[i]</span><br><span class="line">				index = i</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		current[index] -= total</span><br><span class="line">		<span class="keyword">return</span> servers[index].ip</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="权重随机"><a href="#权重随机" class="headerlink" title="权重随机"></a>权重随机</h4><p>权重随机可以类比权重轮询的第一种实现方式，下面直接给出代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WeigthRandom</span><span class="params">(servers []Server)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(servers))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; servers[i].weight; j++ &#123;</span><br><span class="line">			s = <span class="built_in">append</span>(s, servers[i].ip)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		index := rand.Intn(<span class="built_in">len</span>(s))</span><br><span class="line">		<span class="keyword">return</span> s[index]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外还可以使用前缀和的思路，将所有的权重构成一个前缀和数组，比如说权重为<code>[1, 2,3]</code> 的时候，可以形成 <code>[0, 1, 3, 6]</code>，轮询的时候随机生成一个索引(<code>[0,6)</code>之间)，然后到数组中查找对应的范围，比如随机出 5，首先 <code>+1</code>，属于 <code>(3, 6]</code>，所以应该返回最后一个节点，也就是说返回大于等于 <code>随机数+1</code> 的前缀和数组值对应的节点，具体的算法实现见 <code>GitHub</code>[^1]</p>
<h4 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h4><p>我们可以对请求中的某个特定属性计算哈希值，然后根据哈希值寻找对应的服务器节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashLoadBalance</span><span class="params">(servers []<span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		f := fnv.New32()</span><br><span class="line">		f.Write([]<span class="type">byte</span>(key))</span><br><span class="line">		<span class="comment">// 计算 hash 值</span></span><br><span class="line">		h := f.Sum32()</span><br><span class="line">		<span class="comment">// 取模获取对应的服务器</span></span><br><span class="line">		<span class="keyword">return</span> servers[<span class="type">int</span>(h)%<span class="built_in">len</span>(servers)]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用一致性哈希算法</p>
</blockquote>
<h4 id="最小响应时间"><a href="#最小响应时间" class="headerlink" title="最小响应时间"></a>最小响应时间</h4><p>负载均衡器需要统计服务端响应的时间，然后选择平均响应时间最小的服务器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应时间统计</span></span><br><span class="line"><span class="keyword">type</span> RT <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="type">int</span>           <span class="comment">// 多少次</span></span><br><span class="line">	total time.Duration <span class="comment">// 总时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LoadBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">  servers []<span class="type">string</span></span><br><span class="line">	rt      <span class="keyword">map</span>[<span class="type">string</span>]RT <span class="comment">// 响应时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoadBalancer)</span></span> LeastResponseTime() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(l.servers) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	server := l.servers[<span class="number">0</span>]</span><br><span class="line">	min := l.rt[server].total / time.Duration(l.rt[server].count)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择最小的</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(l.servers); i++ &#123;</span><br><span class="line">    rt := l.rt[l.servers[i]]</span><br><span class="line">		average := rt.total / time.Duration(rt.count)</span><br><span class="line">		<span class="keyword">if</span> average &lt; min &#123;</span><br><span class="line">      min = average</span><br><span class="line">			server = l.servers[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小连接数"><a href="#最小连接数" class="headerlink" title="最小连接数"></a>最小连接数</h4><p>和最小响应时间类似，需要负载均衡器维护每一个服务器的连接，然后选择连接数量最少的服务器。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>负载均衡算法是集群部署时常用的算法，合理的负载均衡算法能够更好程度的利用我们的服务器资源，提高系统的承受能力，具体的算法需要根据我们的需求进行选择，比如提供 <code>WebSocket</code> 服务的时候，应该使用 <code>哈希法</code>，根据客户端的 <code>IP</code> 地址计算访问的服务端，从而保证先后访问的服务端都是同一个服务端。</p>
<p>实现代码参见 <a href="https://github.com/junhaideng/LoadBalance">GitHub</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>distribution</tag>
      </tags>
  </entry>
  <entry>
    <title>限流算法</title>
    <url>/2021/11/14/alg/rate-limiter/</url>
    <content><![CDATA[<p>常见的限流算法主要有两种：令牌桶和漏桶算法，也可以使用计数器进行粗暴限流实现。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>维护一个请求数量，在一段时间里，如果请求总数超过了limit，那么我们可以把这个请求拒绝掉，也可以将其放入到缓冲队列中，等待下一个时间段再进行操作。</p>
<span id="more"></span>

<img src="cnt.svg">

<p>例如在上图中，如果时间1~2中出现了110个请求，那么后面的10个请求就会被拒绝掉，如果这一个时间段中的请求数量在100之内，那么每一个请求都会进行响应。</p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>计数器算法中容易出现毛刺，比如说在60s中我们允许100个请求，但是前1s的时候我们就接收到了100个请求，那么后面的59s我们不会对任何的请求进行响应。</p>
<p>在漏桶算法中我们将请求依次添加到桶中间，添加的时候如果桶子已经满了，那么我们将这些请求给丢掉或者缓存，另一端以一定速率对请求进行消费。</p>
<img src="bucket.svg">

<p>一般来说，漏桶是一个FIFO的队列，我们消耗的往往都是最先发起的那一个请求。</p>
<p>漏桶算法可以使得输出变得平滑，因为算法中请求以固定速率进行消费，也正因为如此，所以漏桶算法不支持突发的请求。</p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法是漏桶算法的一种改进，我们设置一个令牌漏斗，桶中初始化一定数量的令牌了，然后按照一定的速率往漏斗中添加令牌，每一个请求到来的时候都会往漏桶中获取需要数量的令牌，如果令牌不够，那么拒绝该请求或者缓存。</p>
<img src="token_bucket.svg">

<p>相较漏桶算法而言，令牌桶算法允许一定程度的突发。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>限流算法需要实现的基本功能就是判断是否能够放行该请求，如果不行的话，给一个需要的等待的时长，决定是否等待该时长，或者丢弃该请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 返回的值表示需要等待的时间</span></span><br><span class="line">	<span class="comment">// 达到这个时间之后才可能获取到</span></span><br><span class="line">	Take(num <span class="type">int</span>) time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码仅为展现实现思路，并未考虑并发问题</p>
<h4 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h4><p>维护一个计数器 <code>count</code>，一段时间后清零。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 当前请求数</span></span><br><span class="line">	count    <span class="type">int</span></span><br><span class="line">	lastTime time.Time</span><br><span class="line">	<span class="comment">// 表示1s中限制允许通过的数量</span></span><br><span class="line">	limit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span></span> Take(num <span class="type">int</span>) time.Duration &#123;</span><br><span class="line">	<span class="comment">// 每隔 1s 清理一次</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="keyword">if</span> now.Sub(c.lastTime) &gt; time.Second &#123;</span><br><span class="line">		c.count = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.lastTime = now</span><br><span class="line">	<span class="comment">// 如果该段时间中还允许 num量级 的请求</span></span><br><span class="line">	<span class="keyword">if</span> c.count+num &lt;= c.limit &#123;</span><br><span class="line">		c.count += num</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 可能需要等待的时间</span></span><br><span class="line">	<span class="keyword">return</span> time.Duration(c.count+num-c.limit) * time.Second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="漏桶算法-1"><a href="#漏桶算法-1" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏桶算法保证请求匀速进行消费，我们需要维护漏桶的容量，已经放入的请求数量，上一次进行消耗请求的时间。<br>当有一个请求到来的时候，首先根据当前的时间和上一次消耗请求的时间，计算这段时间里已经消费了多少的请求，然后添加该请求进去，如果没有超过最大容量，那么允许该请求，如果超过了容量，那么被放弃或者等待。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 桶的容量</span></span><br><span class="line">	capacity <span class="type">int64</span></span><br><span class="line">	lastTime time.Time</span><br><span class="line">	<span class="comment">// 桶中请求的数量</span></span><br><span class="line">	count <span class="type">int64</span></span><br><span class="line">	<span class="comment">// 限制数，最终规整化为 1 duration 中多少个</span></span><br><span class="line">	limit <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bucket)</span></span> Take(num <span class="type">int64</span>) time.Duration &#123;</span><br><span class="line">	<span class="comment">// 首先计算当前的时间差</span></span><br><span class="line">	diff := time.Now().Sub(b.lastTime)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以消费的数量</span></span><br><span class="line">	count := b.limit * <span class="type">int64</span>(diff)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 消耗之后还有多少请求在桶中</span></span><br><span class="line">	b.count -= count</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果桶中还可以放入这么多的</span></span><br><span class="line">	<span class="keyword">if</span> b.count+num &lt; b.capacity &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一次性获取 num 失败，需要再等待多少时间重试</span></span><br><span class="line">	<span class="keyword">return</span> time.Duration((b.count + num - b.capacity) / b.limit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="令牌桶算法-1"><a href="#令牌桶算法-1" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>漏桶算法和令牌桶算法实现的时候比较相似，但是漏桶算法每一轮结算的时候计算消费的请求，减少容器里面的请求数量，而令牌桶算法每轮结算的时候计算产生的令牌数，然后添加到容器中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> token <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 令牌桶容量</span></span><br><span class="line">	capacity <span class="type">int64</span></span><br><span class="line">	lastTime time.Time</span><br><span class="line">	<span class="comment">// 令牌桶中的令牌数量</span></span><br><span class="line">	count <span class="type">int64</span></span><br><span class="line">	<span class="comment">// 每个 duration 允许通过的数量</span></span><br><span class="line">	limit <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *token)</span></span> Take(num <span class="type">int64</span>) time.Duration &#123;</span><br><span class="line">	diff := time.Now().Sub(t.lastTime)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 时间差中可以生成多少的令牌</span></span><br><span class="line">	count := t.limit * <span class="type">int64</span>(diff)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加入令牌</span></span><br><span class="line">	t.count += count</span><br><span class="line">	<span class="comment">// 满了的令牌抛弃</span></span><br><span class="line">	<span class="keyword">if</span> t.count &gt; t.capacity &#123;</span><br><span class="line">		t.count = t.capacity</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 需要的令牌少于桶中的令牌</span></span><br><span class="line">	<span class="keyword">if</span> num &lt;= t.count &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 需要等待多少时间</span></span><br><span class="line">	<span class="keyword">return</span> time.Duration((num - t.count) / t.limit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当系统的 <code>QPS</code> 太高扛不住了，我们可以使用限流算法限制住一部分的流量，比如对于 HTTP 请求可以返回 <code>429</code> 给用户，同时如果说我们只想要用户在一个时间段里面最多请求 n 次，也可以使用限流算法。</p>
<p>在工程运用中，实现限流算法的时候通常会采用无锁操作，这样可以带来更高的效率。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本代码仅为思路讲解，并未考虑并发问题</span></span><br><span class="line"><span class="comment">// 工程运用中一般会考虑无锁操作</span></span><br><span class="line"><span class="comment">// 有兴趣的同学可以参考 https://github.com/uber-go/ratelimit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 返回的值表示需要等待的时间</span></span><br><span class="line">	<span class="comment">// 达到这个时间之后才能获取到</span></span><br><span class="line">	Take(num <span class="type">int</span>) time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 当前请求数</span></span><br><span class="line">	count    <span class="type">int</span></span><br><span class="line">	lastTime time.Time</span><br><span class="line">	<span class="comment">// 表示1s中限制允许通过的数量</span></span><br><span class="line">	limit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span></span> Take(num <span class="type">int</span>) time.Duration &#123;</span><br><span class="line">	<span class="comment">// 每隔 1s 清理一次</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="keyword">if</span> now.Sub(c.lastTime) &gt; time.Second &#123;</span><br><span class="line">		c.count = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.lastTime = now</span><br><span class="line">	<span class="comment">// 如果该段时间中还允许 num量级 的请求</span></span><br><span class="line">	<span class="keyword">if</span> c.count+num &lt;= c.limit &#123;</span><br><span class="line">		c.count += num</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 可能需要等待的时间</span></span><br><span class="line">	<span class="comment">// 为什么可能？因为需要考虑并发</span></span><br><span class="line">	<span class="keyword">return</span> time.Duration(c.count+num-c.limit) * time.Second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 漏桶算法</span></span><br><span class="line"><span class="keyword">type</span> bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 桶的容量</span></span><br><span class="line">	capacity <span class="type">int64</span></span><br><span class="line">	lastTime time.Time</span><br><span class="line">	<span class="comment">// 桶中请求的数量</span></span><br><span class="line">	count <span class="type">int64</span></span><br><span class="line">	<span class="comment">// 限制数，最终规整化为 1 duration 中多少个</span></span><br><span class="line">	limit <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bucket)</span></span> Take(num <span class="type">int64</span>) time.Duration &#123;</span><br><span class="line">	<span class="comment">// 首先计算当前的时间差</span></span><br><span class="line">	diff := time.Now().Sub(b.lastTime)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以消费的数量</span></span><br><span class="line">	count := b.limit * <span class="type">int64</span>(diff)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 消耗之后还有多少请求在桶中</span></span><br><span class="line">	b.count -= count</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果桶中还可以放入这么多的</span></span><br><span class="line">	<span class="keyword">if</span> b.count+num &lt; b.capacity &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一次性获取 num 失败，需要再等待多少时间重试</span></span><br><span class="line">	<span class="keyword">return</span> time.Duration((b.count + num - b.capacity) / b.limit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌桶算法</span></span><br><span class="line"><span class="keyword">type</span> token <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 令牌桶容量</span></span><br><span class="line">	capacity <span class="type">int64</span></span><br><span class="line">	lastTime time.Time</span><br><span class="line">	<span class="comment">// 令牌桶中的令牌数量</span></span><br><span class="line">	count <span class="type">int64</span></span><br><span class="line">	<span class="comment">// 每个 duration 允许通过的数量</span></span><br><span class="line">	limit <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *token)</span></span> Take(num <span class="type">int64</span>) time.Duration &#123;</span><br><span class="line">	diff := time.Now().Sub(t.lastTime)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 时间差中可以生成多少的令牌</span></span><br><span class="line">	count := t.limit * <span class="type">int64</span>(diff)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加入令牌</span></span><br><span class="line">	t.count += count</span><br><span class="line">	<span class="comment">// 满了的令牌抛弃</span></span><br><span class="line">	<span class="keyword">if</span> t.count &gt; t.capacity &#123;</span><br><span class="line">		t.count = t.capacity</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 需要的令牌少于桶中的令牌</span></span><br><span class="line">	<span class="keyword">if</span> num &lt;= t.count &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 需要等待多少时间</span></span><br><span class="line">	<span class="keyword">return</span> time.Duration((num - t.count) / t.limit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rt := &amp;counter&#123;</span><br><span class="line">		<span class="number">0</span>, time.Now(), <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有一个请求会被block</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(rt.Take(<span class="number">1</span>))</span><br><span class="line">		fmt.Println(rt.Take(<span class="number">1</span>))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rt.limit = <span class="number">2</span></span><br><span class="line">	<span class="comment">// 都可以通过</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(rt.Take(<span class="number">1</span>))</span><br><span class="line">		fmt.Println(rt.Take(<span class="number">1</span>))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testBucket</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rt := &amp;bucket&#123;</span><br><span class="line">		<span class="number">1</span>, time.Now(), <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(rt.Take(time.Second.Nanoseconds()))</span><br><span class="line">		fmt.Println(rt.Take(<span class="number">100</span>))</span><br><span class="line">		<span class="comment">// time.Sleep(time.Second)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testToken</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rt := &amp;token&#123;</span><br><span class="line">		<span class="number">10</span>, time.Now(), <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(rt.Take(time.Second.Nanoseconds()))</span><br><span class="line">		fmt.Println(rt.Take(<span class="number">1</span>))</span><br><span class="line">		<span class="comment">// time.Sleep(time.Second)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testCounter()</span><br><span class="line">	<span class="comment">// testBucket()</span></span><br><span class="line">	<span class="comment">// testToken()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>distribution</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>Snowflake ID 算法</title>
    <url>/2021/11/24/alg/snowflake/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>假设我们有一个分布式系统，系统中需要维护全局 <code>id</code> 字段，我们可以把它认为是唯一的标识，不能够重复出现，那么问题来了，我们应该如何生成这样的 <code>id</code> 呢？</p>
<p>其实很容易想到的一种解决方式就是使用 <code>Redis</code> 的键值对了，每次更新的时候直接调用 <code>incr</code>，生成的 id 也是唯一的，还有一种方式就是使用 <code>MySQL</code> 或者其他的数据库，因为我们知道 <code>MySQL</code> 中可以生成自增主键，使用这个主键作为一个分布式 <code>id</code> 也是可行的。</p>
<p>但是上面的这两种方式效率不会特别高，并且依赖于第三方，我们如果想要更高效的生成分布式 <code>id</code>，那么最好的方式就是尽量本地生成，不需要和其他节点进行协商，但是有一个问题出现了，<strong>如何保证 id 不重复？</strong>，我们可以使用 <code>Snowflake</code> 算法来解决该问题。</p>
<span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>Snowflake</code> 可用于在分布式系统中生成唯一的 <code>id</code>，由 <code>Twitter</code> 提出，目前存在很多不同的版本，但是基本的思想是一致的，只不过不同版本不同结构采用的位数不一致。</p>
<p><code>Snowflakes</code> 使用 <code>64</code> 比特， 但是只有 <code>63</code> 位被使用，第一个比特位为符号位，大体结构如下：</p>
<img src="format.svg">

<p><code>timestamp</code> 占 <code>41</code> bits，是生成 <code>ID</code> 的时间戳，也可以是相对某一个特定时间的时间戳差，<code>machine id </code>为分布式系统每一个机器分配到的 <code>id</code> 号，<code>10 bits</code> 表示最多 <code>1024</code> 台机器，<code>sequence number</code> 表示序列号，因为同一个时间戳可能分配多个 <code>id</code>。</p>
<h3 id="ID-生成"><a href="#ID-生成" class="headerlink" title="ID 生成"></a>ID 生成</h3><p>每一台机器的 <code>machine id</code> 都是事先配置好的，可以由数据中心 <code>id</code> 和数据中心的机器 <code>id</code> 组成，直接可以获取到。当我们需要生成一个 <code>id</code> 的时候，首先我们需要获取当前的时间戳，判断是否和上一次的时间戳一致，如果说和上一次的时间戳一致，那么我们应该增加序列号，然后通过移位操作构造对应的一个 <code>64 bits</code> 的 <code>id</code> 号返回。 如果说当前的时间戳与上一次的不同，那么我们直接修改时间戳，然后序列号取零，进行拼接即可。</p>
<img src="flow.svg">

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>算法的实现挺简单的，下面给出核心代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Snowflake)</span></span> GetID() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="comment">// 首先获取当前的时间戳</span></span><br><span class="line">	timestamp := time.Now().UnixMilli()</span><br><span class="line">	<span class="comment">// 相同的时间戳序列号+1</span></span><br><span class="line">	<span class="keyword">if</span> timestamp == s.LastTimestamp &#123;</span><br><span class="line">		s.Sequence = (s.Sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">		<span class="comment">// 重新绕了一圈</span></span><br><span class="line">		<span class="comment">// 同一个时间戳里面生成了很多 id</span></span><br><span class="line">		<span class="keyword">if</span> s.Sequence == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> timestamp &lt;= s.LastTimestamp &#123;</span><br><span class="line">				timestamp = time.Now().UnixMilli()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.Sequence = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重新设置</span></span><br><span class="line">	s.LastTimestamp = timestamp</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行拼接</span></span><br><span class="line">	<span class="keyword">return</span> (timestamp-epoch)&lt;&lt;timestampShift | (s.DatacenterID &lt;&lt; datacenterIDShift) | (s.WorkerID &lt;&lt; workerIDShift) | s.Sequence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>写了一个很简单的基准测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetID</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	s := New(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		s.GetID()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是它的结果，表现还不错吧，这样算起来，假设每次需要 <code>250</code> ns，那么 <code>1s</code> 也可以生成 <code>4,000,000</code> 个不同的 <code>id</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: snowflake</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz</span><br><span class="line">BenchmarkGetID-8         4897538               246.0 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      snowflake       2.069s</span><br></pre></td></tr></table></figure>

<p><code>Twitter</code> 其实也提供了自己的 <code>Scala</code> 实现方式，具体的可以参见 <a href="https://github.com/twitter-archive/snowflake/tree/snowflake-2010">GitHub</a>， 本文的实现方式可以参见 <a href="https://github.com/junhaideng/Blog">我的仓库</a>。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>distribution</tag>
      </tags>
  </entry>
  <entry>
    <title>八大排序算法及其代码实现</title>
    <url>/2021/11/29/alg/sort/</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每次选择数组中的最小元素，排在第一个位置</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[38,65,97,76,13,27,49]</span><br><span class="line">13 [65 97 76 38 27 49]</span><br><span class="line">13 27 [97 76 38 65 49]</span><br><span class="line">13 27 38 [76 97 65 49]</span><br><span class="line">13 27 38 49 [97 65 76]</span><br><span class="line">13 27 38 49 65 [97 76]</span><br><span class="line">13 27 38 49 65 76 [97]</span><br><span class="line">13 27 38 49 65 76 97</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectSort</span><span class="params">(data []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		<span class="comment">// 记录第一个数据</span></span><br><span class="line">		min := data[i]</span><br><span class="line">		index := i</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取到最小的值以及对应的索引</span></span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> min &gt; data[j] &#123;</span><br><span class="line">				min = data[j]</span><br><span class="line">				index = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果最小的值不是当前序列的第一个值</span></span><br><span class="line">		<span class="comment">// 那么需要进行交换</span></span><br><span class="line">		<span class="keyword">if</span> index != i &#123;</span><br><span class="line">			<span class="comment">// 交换最小值</span></span><br><span class="line">			data[index], data[i] = data[i], min</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>假设之前的数组都是一个有序序列，其余的记录为无序序列，从这些无序序列中不断选取数据，插入到前面已经排序好的有序序列中</p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[38] 65 97 76 13 27 49</span><br><span class="line">[38 65] 97 76 13 27 49</span><br><span class="line">[38 65 97] 76 13 27 49</span><br><span class="line">[38 65 76 97] 13 27 49</span><br><span class="line">[13 38 65 76 97] 27 49</span><br><span class="line">[13 27 38 65 76 97] 49</span><br><span class="line">[13 27 38 49 65 76 97]</span><br></pre></td></tr></table></figure>


<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSort</span><span class="params">(data []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">		tmp, j := data[i], i</span><br><span class="line">		<span class="comment">// 如果第j-1个元素比第i个元素大</span></span><br><span class="line">		<span class="comment">// 不满足递增的条件，第i个需要移动到前面</span></span><br><span class="line">		<span class="keyword">if</span> data[j<span class="number">-1</span>] &gt; tmp &#123;</span><br><span class="line">			<span class="comment">// 将第i个元素移动到前面的适当位置</span></span><br><span class="line">			<span class="comment">// 也就是将元素不断的向右边移动，直到找到合适的位置摆放</span></span><br><span class="line">			<span class="keyword">for</span> j &gt;= <span class="number">1</span> &amp;&amp; data[j<span class="number">-1</span>] &gt; tmp &#123;</span><br><span class="line">				data[j] = data[j<span class="number">-1</span>]</span><br><span class="line">				j--</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将当前遍历到的值填充到对应的位置</span></span><br><span class="line">		data[j] = tmp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>基本思路: 从第一个元素开始一次对相邻的记录进行比较， 当前面的记录大于后面的记录，交换其位置，进行一轮比较和换位之后，n个记录中的最大记录将位于第n位</p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;38 65 97 76 13 27 49&#125;</span><br><span class="line">38 65 76 13 27 49 [97]</span><br><span class="line">38 65 13 27 49 [76 97]</span><br><span class="line">38 13 27 49 [65 76 97]</span><br><span class="line">13 27 38 [49 65 76 97]</span><br><span class="line">13 27 [38 49 65 76 97]</span><br><span class="line">13 [27 38 49 65 76 97]</span><br><span class="line">[13 27 38 49 65 76 97]</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	flag := <span class="literal">false</span></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 这里采用的是不断将最大的移动到数组的最后面</span></span><br><span class="line">	<span class="comment">// 当然也可以将最小的移动到最前面来</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n ; i ++&#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n<span class="number">-1</span> -i; j ++&#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]&#123;</span><br><span class="line">				nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">				flag = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !flag&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;一轮遍历中没有进行交换，说明数组已经有序&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(nums)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>将一个数组拆成两份，每一份进行递归操作之后都是有序的，然后进行合并，最终是有序的。</p>
<h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;38 65 97 76 13 27 49&#125;</span><br><span class="line">[38 65 97 76] [13 27 49] </span><br><span class="line">[38 65] [97 76] [13 27] [49]</span><br><span class="line">[38] [65] [97] [76] [13] [27] [49]  // 全部分裂</span><br><span class="line">[38 65] [76 97] [13 27] [49] // 开始进行合并</span><br><span class="line">[38 65 76 97] [13 27 49]</span><br><span class="line">[13 27 38 49 65 76 97]</span><br></pre></td></tr></table></figure>


<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergerSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	mergeSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid := (right-left)/<span class="number">2</span> + left</span><br><span class="line">	mergeSort(nums, left, mid)</span><br><span class="line">	mergeSort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">	merge(nums, left, mid, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个数组，分别是从 left -&gt; mid , mid -&gt; right 索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="type">int</span>, left, mid, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 辅助数据</span></span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="type">int</span>, right-left+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">		tmp[i-left] = nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	i, j := <span class="number">0</span>, mid-left+<span class="number">1</span></span><br><span class="line">	k := left</span><br><span class="line">	<span class="keyword">for</span> k &lt;= right &amp;&amp; i &lt;= mid-left &amp;&amp; j &lt;= right-left &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp[i] &gt; tmp[j] &#123;</span><br><span class="line">			nums[k] = tmp[j]</span><br><span class="line">			k++</span><br><span class="line">			j++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[k] = tmp[i]</span><br><span class="line">			i++</span><br><span class="line">			k++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i &lt;= mid-left &#123;</span><br><span class="line">		nums[k] = tmp[i]</span><br><span class="line">		i++</span><br><span class="line">		k++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j &lt;= right-left &#123;</span><br><span class="line">		nums[k] = tmp[j]</span><br><span class="line">		j++</span><br><span class="line">		k++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种非常高效的排序算法，它采用分而治之的思想，把大的拆分成小的，小的再拆分成更小的。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>对于一组给定的记录，通过一趟排序之后，将原来的序列分成两部分，其中一部分的所有记录均比后一部分的所有记录小，然后再依次对前后两部分的记录进行快速排序，递归改过程，直到序列中的所有记录均有序为止</p>
<blockquote>
<p>可以直接认为是找到了一个分界点，比如如果需要实现递增，那么左边都是小于该数，右边都是大于该数</p>
</blockquote>
<h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>分解：将输入的序列<code>array[m...n]</code> 划分成两个非空子序列<code>array[m...k]</code>和<code>array[k+1...n]</code>，使得<code>array[k+1...n]</code>中的任意一个元素都不小于<code>array[m...k]</code>中的元素</li>
<li>递归求解：通过递归调用快速排序算法分别对<code>array[m...k]</code>和<code>array[k+1...n]</code>进行排序</li>
<li>合并：由于对分解出来的两个子序列的排序是就地进行的，所以在<code>array[m...k]</code>和<code>array[k+1...n]</code>都排好序后不需要执行任何计算<code>array[m...n]</code></li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i := left</span><br><span class="line">	j := right</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选定一个分界点</span></span><br><span class="line">    <span class="comment">// 如果直接下面这种方式取的话，如果数据是有序的，那么时间复杂度相比较会比较高</span></span><br><span class="line">	index := arr[i]</span><br><span class="line">    <span class="comment">// 也可以随机挑选一个</span></span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// rand.Seed(time.Now().UnixNano())</span></span><br><span class="line">	<span class="comment">// var random int </span></span><br><span class="line">	<span class="comment">// random = rand.Int() % (right-left+1) + left</span></span><br><span class="line">    <span class="comment">// 将随机选中的移动到最左边</span></span><br><span class="line">	<span class="comment">// arr[i], arr[random] = arr[random], arr[i]</span></span><br><span class="line">    <span class="comment">// 这里只是为了更新上面的index，如果直接写的话，可以去掉上的赋值，直接使用index:= arr[i]</span></span><br><span class="line">	<span class="comment">// index = arr[i]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">		<span class="comment">// 右边界不断向左移动，如果碰到比index小的数据</span></span><br><span class="line">		<span class="comment">// 则需要将左边的i对应的数据赋值为对应的值</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; j &amp;&amp; arr[j] &gt;= index &#123;</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">			arr[i] = arr[j]</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左边界不断往右移动，如果碰到比index小的数据</span></span><br><span class="line">		<span class="comment">// 则将右边的这个数据赋值索引j对应的数据</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; j &amp;&amp; arr[i] &lt;= index &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">			arr[j] = arr[i]</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 索引i表示的就是</span></span><br><span class="line">    arr[i] = index</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排序左边子数组</span></span><br><span class="line">	sort(arr, left, i<span class="number">-1</span>)</span><br><span class="line">	<span class="comment">// 排序右边</span></span><br><span class="line">	sort(arr, i+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<h4 id="基准关键字的选取"><a href="#基准关键字的选取" class="headerlink" title="基准关键字的选取"></a>基准关键字的选取</h4><p>常用的基准关键字的选取有以下方式:</p>
<ol>
<li>选取首尾，中间位置上的中值作为基准关键字</li>
<li>选取随机数</li>
</ol>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>类似插入排序，但是不是相邻的进行，而是会跳过几个位置</p>
<h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;38, 65, 97, 76, 13, 27, 49&#125;</span><br><span class="line">step为: 3   [38 65 97 76 13 27 49]  // 索引 3 和 0 进行比较并交换</span><br><span class="line">step为: 3   [38 13 97 76 65 27 49]  // 索引 4 和 1 进行比较并交换</span><br><span class="line">step为: 3   [38 13 27 76 65 97 49]  // 索引 5 和 2 进行比较并交换</span><br><span class="line">step为: 3   [38 13 27 49 65 97 76]  // 索引 6 和 3 进行比较并交换</span><br><span class="line">step为: 1   [13 38 27 49 65 97 76]  // 索引 1 和 0 进行比较并交换</span><br><span class="line">step为: 1   [13 27 38 49 65 97 76]  // 索引 2 和 1 进行比较并交换</span><br><span class="line">step为: 1   [13 27 38 49 65 97 76]  // 索引 3 和 2 进行比较并交换</span><br><span class="line">step为: 1   [13 27 38 49 65 97 76]  // 索引 4 和 3 进行比较并交换</span><br><span class="line">step为: 1   [13 27 38 49 65 97 76]  // 索引 5 和 4 进行比较并交换</span><br><span class="line">step为: 1   [13 27 38 49 65 76 97]  // 索引 6 和 5 进行比较并交换</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 步长</span></span><br><span class="line">	<span class="keyword">for</span> step := <span class="built_in">len</span>(nums) / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := step ; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">			<span class="comment">// 直接插入排序</span></span><br><span class="line">			<span class="keyword">if</span> nums[i] &lt; nums[i-step] &#123;</span><br><span class="line">				j, tmp := i, nums[i]</span><br><span class="line">				<span class="comment">// 找出同一组中比tmp小的值，往后面移动step个位置</span></span><br><span class="line">				<span class="keyword">for</span> j &gt;= step &amp;&amp; tmp &lt; nums[j-step] &#123;</span><br><span class="line">					nums[j] = nums[j-step]</span><br><span class="line">					j -= step</span><br><span class="line">				&#125;</span><br><span class="line">				nums[j] = tmp</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>这里说一下递增排序，使用大根堆</p>
<p>大根堆有一个特点，那就是堆的顶部是整个数组中最大的元素，一个比较简单的想法就是，我把这个元素拿出来，然后插入到其他的数组中，堆中 <code>pop</code> 出堆顶的元素，依次进行，便可以获取到一个排序序列，不过这种思路需要多余的一个数组，其实没有必要，我们来自己看看删除元素的过程。</p>
<p>首先，将堆顶的元素和最后一个元素进行交换，然后 <code>size--</code>，进行向下冒泡 <code>down</code>，删除掉最后一个元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(arr *[]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	nums := *arr</span><br><span class="line">	n := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">	nums[<span class="number">0</span>], nums[n] = nums[n], nums[<span class="number">0</span>]</span><br><span class="line">	down(nums, <span class="number">0</span>, n)</span><br><span class="line">	x := nums[n]</span><br><span class="line">	<span class="comment">// 删除最后一个元素</span></span><br><span class="line">	*arr = (*arr)[:n]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里删除最后一个元素，我们可以把这个元素保留在这里，但是让 <code>down</code> 的时候不接触到这个元素不就行了？这个很好实现，因为一般我们都是使用元素的长度作为 <code>down</code> 的一个 <code>size</code> 参数，我们指定一下就好，主要的逻辑代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	size := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 首先建堆</span></span><br><span class="line">	buildHeap(nums)</span><br><span class="line">	<span class="comment">// 然后这个时候最大的元素在第一个</span></span><br><span class="line">	<span class="keyword">for</span> size &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 第一个元素和最后一个进行交换</span></span><br><span class="line">		nums[<span class="number">0</span>], nums[size<span class="number">-1</span>] = nums[size<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">		size--</span><br><span class="line">		down(nums, <span class="number">0</span>, size)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	size := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i := size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		down(nums, i, size)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素的时候需要使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(nums []<span class="type">int</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 父结点计算公式！！</span></span><br><span class="line">		parent := (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">		<span class="comment">// 如果父结点大于子节点了，说明不需要调换，已经满足条件了</span></span><br><span class="line">		<span class="comment">// 如果 i == parent 说明 i = 0 了，没有父结点，也不需要调换</span></span><br><span class="line">		<span class="keyword">if</span> i == parent || nums[parent] &gt; nums[i] &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 父结点没有子节点i的值大，需要调换</span></span><br><span class="line">		nums[parent], nums[i] = nums[i], nums[parent]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化的时候需要建堆</span></span><br><span class="line"><span class="comment">// 删除元素的时候需要down：</span></span><br><span class="line"><span class="comment">// 将第一个元素和最后一个元素进行调换, 然后重新 down(nums, 0, size)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(nums []<span class="type">int</span>, i <span class="type">int</span>, size <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	left, right := <span class="number">2</span>*i+<span class="number">1</span>, <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">	j := i</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到最大的元素的下标</span></span><br><span class="line">	<span class="keyword">if</span> left &lt; size &amp;&amp; nums[left] &gt; nums[j] &#123;</span><br><span class="line">		j = left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> right &lt; size &amp;&amp; nums[right] &gt; nums[j] &#123;</span><br><span class="line">		j = right</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> j != i &#123;</span><br><span class="line">		nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">		down(nums, j, size)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用递归也可以</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down2</span><span class="params">(nums []<span class="type">int</span>, i, size <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		left, right := i*<span class="number">2</span>+<span class="number">1</span>, i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">		<span class="comment">// 说明i是叶子节点</span></span><br><span class="line">		<span class="keyword">if</span> left &gt;= size &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到最大的节点</span></span><br><span class="line">		largest := i</span><br><span class="line">		<span class="keyword">if</span> left &lt; size &amp;&amp; nums[left] &gt; nums[largest] &#123;</span><br><span class="line">			largest = left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> right &lt; size &amp;&amp; nums[right] &gt; nums[largest] &#123;</span><br><span class="line">			largest = right</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> largest != i &#123;</span><br><span class="line">			nums[i], nums[largest] = nums[largest], nums[i]</span><br><span class="line">			i = largest</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果最大的节点就是本身，那么后面也不需要进行操作了</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从堆中弹出一个数</span></span><br><span class="line"><span class="comment">// 首先将堆顶的元素和最后一个元素进行调换，然后进行down操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(arr *[]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	nums := *arr</span><br><span class="line">	n := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	nums[<span class="number">0</span>], nums[n] = nums[n], nums[<span class="number">0</span>]</span><br><span class="line">	down(nums, <span class="number">0</span>, n)</span><br><span class="line">	x := nums[n]</span><br><span class="line"></span><br><span class="line">	*arr = (*arr)[:n]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	size := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// 首先建堆</span></span><br><span class="line">	buildHeap(nums)</span><br><span class="line">	<span class="comment">// 然后这个时候最大的元素在第一个</span></span><br><span class="line">	<span class="keyword">for</span> size &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 第一个元素和最后一个进行交换</span></span><br><span class="line">		nums[<span class="number">0</span>], nums[size<span class="number">-1</span>] = nums[size<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">		size--</span><br><span class="line">		down(nums, <span class="number">0</span>, size)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>设置一个长度为元素最大值最小值的空间，将元素一个一个对应一个索引，如果这个索引中已经存在元素，那么对应的值+1，说明这个索引处对应多个元素，最后遍历一遍这个索引空间，值为0的不需要添加，值为多个的一次添加到原数组中</p>
<p>计数排序适合于数组中的值在一定范围内的数据，比如说年龄，数据可能需要进行整理，比如 [10000, 20000] 的数据，我们可以首先整理为 [0, 10000]，然后再转换回去。</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如我们需要排序年龄，那么我们可以估算年龄在[0,200]中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        count[num] ++ </span><br><span class="line">    &#125;</span><br><span class="line">    index := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(count); i ++ &#123;</span><br><span class="line">        <span class="comment">// 出现了多少次，排序后添加到原数组多少次</span></span><br><span class="line">        <span class="keyword">for</span> j:= <span class="number">0</span>; j &lt; count[i]; j++ &#123;</span><br><span class="line">            nums[index] = i </span><br><span class="line">            index ++ </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表给出了每种排序算法的稳定性和效率的比较：</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>最好时间</th>
<th>平均时间</th>
<th>最坏时间</th>
<th>辅助储存</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>简单选择排序</td>
<td>$$O(n^2)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(1)$$</td>
<td>不稳定</td>
<td>n小时较好</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>$$O(n)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(1)$$</td>
<td>稳定</td>
<td>大部分有序时较好</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$$O(n)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(1)$$</td>
<td>稳定</td>
<td>n小时较好</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$$O(n)$$</td>
<td>$$O(n\log n)$$</td>
<td>$$O(sn)\ 1&lt;s&lt;2$$</td>
<td>$$O(1)$$</td>
<td>不稳定</td>
<td>s是所选分组</td>
</tr>
<tr>
<td>快速排序</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n^2)$$</td>
<td>$$O(\log n)$$</td>
<td>不稳定</td>
<td>n大时较好</td>
</tr>
<tr>
<td>堆排序</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n\log n)$$</td>
<td>$$O(1)$$</td>
<td>不稳定</td>
<td>n大时较好</td>
</tr>
<tr>
<td>归并排序</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n\log n)$$</td>
<td>$$O(n)$$</td>
<td>稳定</td>
<td>n大时较好</td>
</tr>
</tbody></table>
<p>如果想要更直观的看排序过程，推荐使用 <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a> 这个网站进行理解。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人博客？</title>
    <url>/2021/12/21/blog/deploy/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每一个技术同学都希望能够拥有一份自己的博客，有时候在上面写写东西，不需要太多，不需要炫彩夺目，简简单单就好，如果自己的文章能够帮助到他人那就更加欢喜不得了。</p>
<p>第一次看到 CSDN 上的写的<a href="https://blog.csdn.net/weixin_44676081/article/details/103145416">一篇文章</a>如此受大家的喜欢，甚是喜悦，后来又陆陆续续写了很多文章，不论是写代码时遇到的 bug 解决思路，还是刚学习某门语言时碰到的问题，亦或是学的某些算法等等。</p>
<p>收到 GitHub 上许多同学的点赞之后，也越来越喜欢开源自己写的 <code>Project</code>，同时 GitHub 上有着许许多多的有些仓库值得我们去学习。</p>
<p>在 <code>CSDN</code> 和 <code>掘金</code> 上写了这么些文章，但总是觉点欠缺点什么，前不久看到其他同学的博客，于是想着搭建自己的一份博客，一来可以方便内容的聚集，二来也算是满足自己的一个小小的愿望，谁不想要有自己的博客呢😄</p>
<span id="more"></span>

<h1 id="选材"><a href="#选材" class="headerlink" title="选材"></a>选材</h1><p>网上其实有很多的博客模板，我们也没有必要从零开始搭建一个博客，当然，如果有时间有能力的话，也未尝不可是一次很好的尝试呢，因为在尝试的过程中，你可能会遇到很多问题，而这些问题恰恰就是你学习的机会。</p>
<p>在这里，我选择的是 <a href="https://hexo.io/">Hexo</a> 博客模板再加上 <a href="https://ppoffice.github.io/hexo-theme-icarus/">Icarus</a> 主题，选择 Hexo 博客模板是因为其支持 <code>Markdown</code> 编写文章，并且生态很好，对于主题的挑选随自己的心愿，可以到<a href="https://hexo.io/themes/">主题</a>模块去探索符合自己口味的。</p>
<p>刚开始选择的主题是 <a href="https://theme-next.js.org/">NexT</a>，长下面这样，其实还可以，自定义之后也可以做的很好看。</p>
<img src="next.png">

<p>后来看到了 Icarus 主题，经过配置之后达到下面的效果，这才是我想要的主题嘛，简洁大方，界面UI也做的很不错。</p>
<img src="icarus.png">

<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>下面假设已经预先安装好了 <a href="https://nodejs.org/en/">Node.js</a> 和 <a href="https://git-scm.com/">Git</a>，若尚未安装好，可以进入相应的官网进行下载安装，过程比较简单，这里不再赘述。</p>
<h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><p><code>Hexo</code> 提供了脚手架，我们可以方便的创建博客，首先进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装完成之后，如果执行 <code>hexo -v</code> 可以返回对应的版本号，则安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.22000</span><br><span class="line">node: 14.17.4</span><br><span class="line">v8: 8.4.371.23-node.76</span><br><span class="line">uv: 1.41.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.17.1</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.42.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">openssl: 1.1.1k</span><br><span class="line">cldr: 39.0</span><br><span class="line">icu: 69.1</span><br><span class="line">tz: 2021a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>

<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>首先执行 <code>hexo init [name]</code> 初始化博客。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  hexo init blog</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">...</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>

<p>博客项目初始化完成之后，我们就已经搭建了一个很简单的博客网站了，运行 <code>hexo server</code> 或者 <code>hexo s</code> 命令，运行博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>样式如下，依个人看法，十分丑陋😂</p>
<img src="hexo.png">



<h2 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2><p>使用 <code>hexo new [title]</code> 即可创建一篇文章，使用 <code>markdown</code> 进行编写即可，创建的文件在 <code>source/_posts/test.md</code>。</p>
<p>如果需要引入图片的话，注意这里不能直接引入本地图片，可以首先创建一个界面，然后将图片放置在该目录中：</p>
<ul>
<li>首先创建 <code>images</code> 界面：<code>hexo new page images</code>，其实相当于多了二级路由 <code>/images</code></li>
<li>将需要添加的图片放在 images 目录下，可以在其中再创建目录</li>
<li>使用绝对路径引用图片：比如 <code>img</code> 标签的 <code>src</code> 应为 <code>/images/test.png</code>，<code>i/mages/blog/test.png</code></li>
</ul>
<p>当然如果说想要直接引用本地文件，可以参考 <a href="https://hexo.io/zh-cn/docs/asset-folders">asset-folders</a>，首先将配置文件 <code>_config.yml</code> 中的 <code>post_asset_folder</code> 设置为 <code>true</code>，创建新文章时自动创建一个文件夹，这个资源文件夹将会有与这个文章文件一样的名字，需要的资源放在该目录中，即可通过相对路径访问了。举个栗子，文章 <code>test.md</code> 对应的<code>test</code> 目录下放了一个 <code>go.png</code>，那么在 <code>test.md</code> 中可以使用 <code>&lt;img src=&quot;go.png&quot;&gt;</code> 进行引用。</p>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>美化，当然要看主题了，<code>Hexo</code> 主要提供的是一个框架，我们可以任意选择主题，当然也可以自制主题，只不过成本比较高，下面以 <code>Icarus</code> 主题为例，演示如何设置主题。</p>
<p>首先下载对应的主题文件，这里推荐使用 <code>git clone</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus </span><br></pre></td></tr></table></figure>

<p>然后在 <code>_config.yml</code> 中配置主题为 <code>icarus</code>，或者使用命令 <code>hexo config theme icarus</code> 进行设置，然后重启即可，效果如下：</p>
<img src="icarus-theme.png">

<p>过程中可能有些模块没有安装，使用 <code>npm install</code> 或者 <code>yarn add</code> 添加即可。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>这里使用 <code>GitHub Pages</code> 进行部署，不需要自己购买服务器，当然如果想部署在自己的服务器也是可以的，推荐使用 <code>Nginx</code> 搭建，下面进行演示。</p>
<p>在 GitHub 创建一个仓库，命名为 <code>&lt;your name&gt;.github.io</code>，比如用户名为<code>xiaoming</code> 的同学应该命名为<code>xiaoming.github.io</code>。</p>
<p>然后在 <code>_config.yml</code> 中进行配置，这里注意需要把本地的 <code>ssh</code> 公钥添加到 <a href="https://github.com/settings/keys">GitHub</a> 中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 url</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://junhaideng.github.io/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置部署的仓库</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&#x27;git@github.com:junhaideng/junhaideng.github.io.git&#x27;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&#x27;main&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>npm run deploy</code>，项目即可部署，其实就是相当于把打包后的文件通过 <code>Git</code> 上传到仓库中。进入代码仓库的 <code>Settings &gt; Pages</code>，可以看到项目已经成功部署。</p>
<img src="github_pages.png">

<h2 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h2><p><code>Icarus</code> 中支持丰富的插件和个性化配置，比如 <strong>百度统计</strong>、<strong>Latex公式</strong>、<strong>布局样式</strong>等等，同时也支持评论，使用 <code>Gitalk</code> 十分简单的就可以搭建一个评论系统，这些就留给读者慢慢探索了，其<a href="https://ppoffice.github.io/hexo-theme-icarus">官方文档</a>中也有详细说明。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>deploy</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基本使用</title>
    <url>/2021/07/10/docker/basic/</url>
    <content><![CDATA[<p><code>Docker</code> 是一个现代化的容器技术，使用它我们可以轻松的将应用进行打包，然后移植到其他系统，不必要在不同设备上反复配置对应的环境。</p>
<p>下面介绍一下基本使用：</p>
<h2 id="从一个Hello-world开始"><a href="#从一个Hello-world开始" class="headerlink" title="从一个Hello world开始"></a>从一个Hello world开始</h2><p>Docker 可以允许你在容器中运行应用程序，使用 <code>docker run</code> 可以在容器中运行一个应用程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:18.04 /bin/echo <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>run</code>: 表示运行一个容器</li>
<li><code>ubuntu:18.04</code>: 指定要运行的镜像，Docker 首先在本地主机上查找对应的镜像是否存在，如果不存在的话，那么会从远程镜像仓库 <code>Docker Hub</code> 中下载公共镜像，如果没有指定后面的 TAG，那么默认情况下使用的是 latest</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>: 在启动的容器中执行的命令</li>
</ul>
<span id="more"></span>

<p>运行完上面的命令之后，我们会下载一个 <code>ubuntu</code> 镜像，并且创建一个容器，使用下面的命令可以查看所有的镜像文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>如果我们不需要这些容器了，我们可以使用下面命令进行删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># container 指的是容器的ID或者NAME，可以一次性删除多个</span></span><br><span class="line">docker <span class="built_in">rm</span> container [container...]</span><br></pre></td></tr></table></figure>

<h3 id="运行交互式容器"><a href="#运行交互式容器" class="headerlink" title="运行交互式容器"></a>运行交互式容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:18.04 /bin/bash</span><br><span class="line"><span class="comment"># -i -t 可以合并为-it</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-t</code>: 在新容器中指令一个伪终端或终端</li>
<li><code>-i:</code> 允许对容器中的标准输入(stdin)进行交互</li>
</ul>
<p>输入<code>exit</code>可以退出当前容器</p>
<h3 id="运行后台模式容器"><a href="#运行后台模式容器" class="headerlink" title="运行后台模式容器"></a>运行后台模式容器</h3><p>使用下面的命令可以创建一个以进程方式运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行完上面的命令之后会输出一串字符串，表示的是这个 <code>容器ID</code></p>
<h2 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h2><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>如果本地没有镜像，那么可以使用下面的命令获取 <code>ubuntu</code> 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>

<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>使用下面命令启动一个容器，并且以命令行模式进入该容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br><span class="line"><span class="comment"># 默认使用的就是 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>exit</code> 可退出终端</p>
<h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>在大部分的场景下，我们希望 <code>docker</code> 的服务是在后台运行的，使用 <code>-d</code> 参数指定容器以 <code>守护进程</code> 的形式运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="启动、停止容器"><a href="#启动、停止容器" class="headerlink" title="启动、停止容器"></a>启动、停止容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop container</span><br><span class="line"><span class="comment"># 启动一个已经停止的容器</span></span><br><span class="line">docker start container</span><br><span class="line"><span class="comment"># 重启一个容器</span></span><br><span class="line">docker restart container</span><br></pre></td></tr></table></figure>

<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在使用 <code>-d</code> 参数时，容器启动会进入后台，此时如果想要进入容器，可以使用下面的指令进入</p>
<ul>
<li><code>docker attach container</code></li>
<li><code>docker exec container</code><blockquote>
<p>推荐使用 docker exec，因为使用这个方式退出终端之后不会导致容器的停止</p>
</blockquote>
</li>
</ul>
<p>使用 <code>docker exec</code> 的时候需要指定运行的命令，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure>

<p>而使用 <code>docker attach</code> 的时候会直接进行上一次的命令</p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> container</span><br></pre></td></tr></table></figure>

<p>删除容器的时候必须是停止状态</p>
<h4 id="查看网络端口映射"><a href="#查看网络端口映射" class="headerlink" title="查看网络端口映射"></a>查看网络端口映射</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PORTS信息中有</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定容器的端口映射</span></span><br><span class="line">docker port container</span><br></pre></td></tr></table></figure>

<h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs container</span><br></pre></td></tr></table></figure>

<h4 id="查看容器的进程"><a href="#查看容器的进程" class="headerlink" title="查看容器的进程"></a>查看容器的进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top container</span><br></pre></td></tr></table></figure>

<h4 id="检查容器"><a href="#检查容器" class="headerlink" title="检查容器"></a>检查容器</h4><p>输出容器的一系列信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect container</span><br></pre></td></tr></table></figure>

<h3 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h3><p>当运行容器的时候，如果使用的容器本地不存在，那么 <code>docker</code> 会自动从镜像仓库中下载，默认是 <code>Docker Hub</code> 公共镜像源</p>
<h4 id="列出所有镜像列表"><a href="#列出所有镜像列表" class="headerlink" title="列出所有镜像列表"></a>列出所有镜像列表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h4 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>

<h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search xxx</span><br></pre></td></tr></table></figure>

<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>镜像的删除使用 docker rmi 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi imageName</span><br></pre></td></tr></table></figure>

<h4 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag container xxx:xxx</span><br></pre></td></tr></table></figure>

<h3 id="Docker-容器网络连接"><a href="#Docker-容器网络连接" class="headerlink" title="Docker 容器网络连接"></a>Docker 容器网络连接</h3><p>容器中可以运行一些网络应用，要想让外部也可以访问里面的这些应用，那么可以通过 <code>-P</code> 或者 <code>-p</code> 参数来指定端口映射</p>
<h4 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h4><p>比如说运行一个 python 应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P webapp python app.py</span><br><span class="line"><span class="comment"># 将容器内容的5000(2)端口映射到宿主机的5000(1)端口</span></span><br><span class="line">docker run -d -p 5000:5000 webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-P</code>: 容器里面的端口随机映射到主机端口</li>
<li><code>-p</code>: 容器内部端口绑定到指定的主机端口</li>
<li>端口进行映射之后，我们可以使用 <code>docker ps</code> 或者 <code>docker port container</code> 进行查看对应的端口映射关系</li>
</ul>
<p>默认情况下绑定的都是 <code>tcp</code> 端口，如果要绑定 <code>udp</code> 端口，可以再端口后面加 <code>/udp</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp webapp python app.py</span><br></pre></td></tr></table></figure>

<h4 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h4><p>端口映射不是唯一的将 <code>docker</code> 连接到另一个容器的方法<br><code>docker</code> 有一个连接系统允许将多个容器连接在一起，共享连接信息<br><code>docker</code> 连接会创建一个父子关系，其中父容器可以看到子容器的信息</p>
<h5 id="端口命名"><a href="#端口命名" class="headerlink" title="端口命名"></a>端口命名</h5><p>当我们创建一个容器的时候，docker 会自动对它进行命名，我们可以使用 <code>--name</code> 参数来自定义命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name ubuntu -t ubuntu:18.04 /bin/bash</span><br><span class="line"><span class="comment"># 下面方法可以修改一个container的name</span></span><br><span class="line">docker rename container NEW_NAME</span><br></pre></td></tr></table></figure>

<h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge test-net</span><br><span class="line"><span class="comment"># -d 表示新建网络内省，有bridge, overlay</span></span><br></pre></td></tr></table></figure>

<h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的网络中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name test1 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后在打开一个新的终端运行一个容器并加入到 test-net 网络中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name test2 --network test-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后可以在容器之间进行 ping</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping test1  <span class="comment"># test2内</span></span><br><span class="line">ping test2  <span class="comment"># test1内</span></span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 可以用来构建一个镜像，文本内容包含了一条条构建镜像所需要的指令和说明</p>
<h3 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /server</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /server</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install --production</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><code>FROM</code> 指定使用哪一个镜像源<br><code>RUN</code> 指定要执行的命令<br><code>COPY</code> 执行相应的复制操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t centos:6.7 DockerfilePath</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-t</code>: 指定创建的目标镜像名</li>
<li><code>DockerfilePath</code>: 指定需要使用的 <code>Dockerfile</code> 文件，也可以指定所在目录，但是这样目录中的构建文件名必须是 <code>Dockerfile</code></li>
</ul>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 Dockerfile 文件的存放目录下，执行构建动作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>

<p><code>.</code>, 上下文路径， 可以用 Dockerfile 的路径来代替，也可以使用目录，只不过构建文件名必须为 Dockerfile</p>
<h3 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h3><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><code>--chown=</code>：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
<p><code>源路径</code>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在 <code>docker run</code> 时运行。</li>
<li>RUN 是在<code>docker build</code>。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt;</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span></span><br></pre></td></tr></table></figure>

<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>

<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>声明端口</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录。用 <code>WORKDIR</code> 指定的工作目录，会在构建镜像的每一层中都存在。（<code>WORKDIR</code> 指定的工作目录，必须是提前创建好的）。</p>
<p><code>docker build</code> 构建镜像过程中的，每一个 <code>RUN</code> 命令都是新建的一层。只有通过 <code>WORKDIR</code> 创建的目录才会一直存在。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希</title>
    <url>/2021/11/09/alg/consistent-hash/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在介绍一致性哈希之前，首先来看看集群部署可能发生的问题：比如说我现在有5台 <code>Redis</code> 服务器，正常运行了很久，很不巧有一天A服务器崩溃了，这个时候还有4台服务器，系统还可以正常运行，原来发送到A服务器的请求我们肯定要想办法进行重定向吧，如果说我们使用一般的哈希函数进行分配，无疑是 <code>hash(key) % num</code>，不过因为 <code>num</code> 现在变成了 <code>num-1</code>，那么很有可能所有的请求都会发生改变打到不同的服务器上，原来发送到B的请求重新处理之后可能发送到了C服务器了。</p>
<span id="more"></span>

<img src="hash.svg">

<p>为了规避这种大迁移情况，我们可以使用一致性哈希。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>一致性哈希算法使用的也是取模，但是不同于普通的哈希，我们不是对服务器的数量进行取模，而是对 <code>2^32</code> 取模，也就是相当于对一个固定的数进行取模，我们可以这样认为：所有的哈希值空间构成了一个圆环，如下图：</p>
<img src="1.svg">

<p>如果我们有多个服务器的，根据某个属性计算哈希值，比如说IP地址，映射到圆环上对应节点，假设说现在我有三个节点，映射之后的结果如下: </p>
<img src="2.svg">

<p>当某个请求发送过来的时候，根据其中的某个属性计算哈希值，比如说<code>HTTP</code>请求的路径，头部信息等，假设映射到如下的位置</p>
<img src="3.svg">

<p>根据映射到的位置，我们选择<code>顺时针旋转</code>遇到的第一个服务器节点作为该请求所选择的服务器节点，也就是 <code>B</code> 服务器。</p>
<p>当我们的某台服务器崩溃的时候，比如 <code>B</code> 崩溃了，那么 <code>A</code> 请求根据一致性哈希原理，会分配到服务器节点 <code>C</code>，更一般的，<code>(A, B]</code> 范围中的请求都会重新分配到服务器节点 <code>C</code>，而其他的请求都不会发生改变，这和之前所述的普通哈希函数不同。</p>
<p>但是上述的算法在某些情况下表现不好，比如说下面的这种服务器节点分布：</p>
<img src="4.svg">

<p><code>C</code> 一个节点就占用了大概<code>2/3</code>的取值空间，导致请求分配非常不均匀，针对这种情况，我们可以通过设置多个节点副本，如下：</p>
<img src="5.svg">

<p>这样处理之后，比之前而言要均匀了很多，理论来说，副本的数量越多，分配的越均匀，但是同时也会增加管理的难度，所以不宜设置过大。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>先简单说一下思路吧，按照上面的原理，我们需要：</p>
<ul>
<li>hash 函数：能够支持多副本</li>
<li>服务器节点映射：哈希值-&gt;服务器节点</li>
<li>映射的值范围：类似上面的取值圆环<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> consistent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 副本数量</span></span><br><span class="line">	replicas <span class="type">int</span></span><br><span class="line">	<span class="comment">// 所有的server 节点</span></span><br><span class="line">	nodes <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 节点所对应的server</span></span><br><span class="line">	servers <span class="keyword">map</span>[<span class="type">uint32</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">// 保存所有的索引，也就是在hash圆环上的节点</span></span><br><span class="line">	circle uints <span class="comment">// type uints []uint32</span></span><br><span class="line">	<span class="comment">// 采用的hash算法</span></span><br><span class="line">	<span class="comment">// hash 方法可能直接决定节点的分布情况</span></span><br><span class="line">	hash Hash</span><br><span class="line">	sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当一个服务器节点进行映射的时候，会得到多个哈希值(多个副本)，这些哈希值在圆环上对应一个位置</li>
</ul>
<img src="6.svg">

<p>但是我们没必要保存一个 <code>2^31-1</code> 大的数组，我们只需要维护一个<code>有序数组</code>就好了，当一个请求过来的时候，我们只需要获取到它的哈希值顺时针的下一个节点哈希值对应的服务器节点就好了</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数应该能够支持多副本，方式有很多种，这里采用一个简单的方式，也可以自定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;hash/fnv&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// replica</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(key <span class="type">string</span>, num <span class="type">int</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	h := fnv.New32()</span><br><span class="line">	h.Write([]<span class="type">byte</span>(key + <span class="string">&#x27;-&#x27;</span>+ strconv.Itoa(num)))</span><br><span class="line">	<span class="keyword">return</span> h.Sum32()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务器节点映射"><a href="#服务器节点映射" class="headerlink" title="服务器节点映射"></a>服务器节点映射</h4><p>服务器节点进行哈希之后，需要保存对应的哈希值，这样可以通过哈希值获取到对应的服务器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">servers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint32</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<h4 id="映射值的范围"><a href="#映射值的范围" class="headerlink" title="映射值的范围"></a>映射值的范围</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">circle := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>每一次添加节点的时候，都需要进行重新排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; replicas; i++ &#123;</span><br><span class="line">  key := hash(node, i)</span><br><span class="line">  circle = <span class="built_in">append</span>(c.circle, key)</span><br><span class="line">  servers[key] = node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重新进行排序</span></span><br><span class="line">sort.Sort(c.circle)</span><br></pre></td></tr></table></figure>
<p>而在删除节点的时候，我们只需要删除对应节点的哈希值，顺序维持不变即可。</p>
<h4 id="支持的方法"><a href="#支持的方法" class="headerlink" title="支持的方法"></a>支持的方法</h4><p>主要支持的方法不是很多，基本的有：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConsistentHasher <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加节点</span></span><br><span class="line">	Add(slot <span class="type">string</span>)</span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	Delete(slot <span class="type">string</span>)</span><br><span class="line">	<span class="comment">// 数据对应的节点</span></span><br><span class="line">	Get(key <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加服务器节点上面已经说了，删除节点的主要代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *consistent)</span></span> Delete(node <span class="type">string</span>) &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="built_in">delete</span>(c.nodes, node)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为在数组中删除元素不方便，这里先记录一下需要删除的数据</span></span><br><span class="line">	<span class="comment">// 然后如果在这里面的数据就不再添加到新的记录中</span></span><br><span class="line">	memo := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint32</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除hash圆环中的值</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c.replicas; i++ &#123;</span><br><span class="line">		key := c.hashKey(node, i)</span><br><span class="line">		memo[key] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="built_in">delete</span>(c.servers, key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个新的保存</span></span><br><span class="line">	newCircle := <span class="built_in">make</span>(uints, <span class="number">0</span>, c.circle.Len()-c.replicas)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c.circle.Len(); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := memo[c.circle[i]]; !ok &#123;</span><br><span class="line">			newCircle = <span class="built_in">append</span>(newCircle, c.circle[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.circle = newCircle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要获取一个请求对应的服务器节点的时候，我们只要搜索到顺序针第一个服务器节点即可，因为哈希值有序，这里可以采用<code>二分查找</code>的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get 获取到属于的server节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *consistent)</span></span> Get(name <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	c.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.RUnlock()</span><br><span class="line">	<span class="comment">// 首先将hash找到</span></span><br><span class="line">	key := c.hash(name)</span><br><span class="line">	<span class="comment">// 然后在Hash圆环上找到对应的节点</span></span><br><span class="line">	i := sort.Search(<span class="built_in">len</span>(c.circle), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> c.circle[i] &gt;= key &#125;)</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 顺时针计算应该就是第一个节点了</span></span><br><span class="line">  <span class="keyword">if</span> i &gt;= c.circle.Len() &#123;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.servers[c.circle[i]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现代码已经上传到 <a href="https://github.com/junhaideng/consistent">GitHub</a> 上了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一致性哈希在加入和删除节点的时候只会影响相邻的节点，对其他的节点无影响。当节点数量发生变化，我们不希望映射关系全部被打乱的时候，可以采用该算法。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>distribution</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基本使用</title>
    <url>/2021/12/18/git/basic/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当我们看到 <code>Git</code> 的时候，涌现上来的第一个想法就是 <code>Git</code> 是什么，我们为什么要使用 <code>Git</code> ？</p>
<p>首先解决一下第一个问题，Git 是什么？</p>
<p><code>Git</code> 官网上有一段说明: <code>Git</code>  is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 翻译一下就是说：<code>Git</code> 是一个免费的开源分布式版本控制系统，旨在快速且高效地处理从小型到大型的所有项目。</p>
<span id="more"></span>

<p>这里简单说明一下版本控制系统是什么，打个比方，我们有一段完整的代码，不过现在我们需要在此基础上进行新功能的开发，开发完成之后上线了，不过很不幸，上线之后出现了很多 bug，那应该怎么处理，不用想，第一件事肯定是回滚，采用之前运行正确的代码，如果我们没有采用 <code>Git</code> ，那我们就需要保存一份之前的源代码了，如果我们采用 <code>Git</code> ，那么我们可以很方便的将代码切换到历史中的每一条记录，这就叫做版本控制。</p>
<p>介绍完了什么是 <code>Git</code> ，那么我们为什么要用 <code>Git</code>  呢？ </p>
<p>首先，互联网公司都在用 <code>Git</code> ，当你参加工作的时候，无法避免地会使用 <code>Git</code> ，比如暑期在字节实习的时候，公司内部自己搭建了一个 <code>Git</code> lab，代码的提交都是使用 <code>Git</code>  进行的，你如果不知道怎么使用 <code>Git</code> ，那么你写好的代码就只能让其他同学帮忙上传，效率极低，而且同学不可能一直帮你吧，所以说学习 <code>Git</code>  很必要。</p>
<p>其次，<code>Git</code> 的分布式版本控制系统真的很棒，在公司里面一个项目往往是一组同学一块开发，不可能单枪匹马，不同的同学负责不同的模块，这个时候 <code>Git</code>  的作用就更明显了，开发不同 <code>feature</code> 的同学统一从仓库上拉取代码，然后在本地另外创建一个分支进行新功能开发，开发完成，测试通过，代码进行 <code>review</code> 之后合入主干分支，极大的提高了编码效率。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>访问 <a href="https://git-scm.com/">Git 官网</a> 下载，如果是 <code>Linux</code> 系统，基本上都会预装 <code>Git</code> ，如果没有，对于 <code>Ubuntu</code> 来说可以使用下面的命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git -all</span><br></pre></td></tr></table></figure>

<p>安装完成之后，进入命令行输入下方命令进行检查，如果输出版本号，则说明安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git  --version</span><br><span class="line">git version 2.25.1</span><br></pre></td></tr></table></figure>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先介绍一下 <code>Git</code>  中的基本术语：<code>工作区, 暂存区，版本库</code>。</p>
<ul>
<li><strong>工作区</strong>：就是在电脑里能看到的目录，或者直接认为是我们在编写项目的目录。</li>
<li><strong>暂存区</strong>：一般存放在 <code>.git</code> 目录下的 <code>index</code> 文件中，所以我们把暂存区有时也叫作索引 (index)。</li>
<li><strong>版本库</strong>：工作区有一个隐藏目录 <code>.git</code>，不算工作区，而是 <code>Git</code>  的版本库，提交到这里都会形成一个版本，想要要切换到任意版本都很简单。</li>
</ul>
<p>下面我们就开始介绍一些常用的命令</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置全局用户，去掉 --global 参数表示配置当前目录用户</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>有两种方式，下面分别讲解：</p>
<p>一种是在本地直接创建，使用 <code>git init</code>，创建之后会生成一个 <code>.git</code> 目录</p>
<ul>
<li>在当前目录进行创建：<code>git init</code></li>
<li>在指定目录进行创建：<code>git init repo</code></li>
</ul>
<p>另外一种方式是从远程仓库克隆下来，使用 <code>git clone</code></p>
<ul>
<li>克隆到目录，目录名为仓库名：<code>git clone</code></li>
<li>克隆到指定目录：<code>git clone &lt;dir&gt;</code></li>
</ul>
<h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><p><code>git add</code> 命令可将该文件添加到暂存区，可以支持多个文件以及通配符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个文件</span></span><br><span class="line">git add README.md</span><br><span class="line"><span class="comment"># 添加 src 目录下的文件</span></span><br><span class="line">git add src/</span><br><span class="line"><span class="comment"># 添加当前目录所有</span></span><br><span class="line">git add . </span><br></pre></td></tr></table></figure>

<h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><p><code>git status</code> 查看仓库当前的状态，显示有变更的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span> &gt; README.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        README.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br><span class="line">$ git add README.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   README.md</span><br></pre></td></tr></table></figure>

<h4 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h4><p><code>git diff</code> 可以比较同一文件在<strong>暂存区和工作区</strong>的差异。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff README.md</span><br><span class="line">diff --git a/branch/README.md b/branch/README.md</span><br><span class="line">index ce01362..3b18e51 100644</span><br><span class="line">--- a/branch/README.md</span><br><span class="line">+++ b/branch/README.md</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure>

<h4 id="提交本地仓库"><a href="#提交本地仓库" class="headerlink" title="提交本地仓库"></a>提交本地仓库</h4><p><code>git commit</code> 可以将代码添加到本地仓库，添加到这里的代码之后可以恢复。</p>
<h4 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h4><p><code>get reset</code> 可以将代码回退到指定的版本，默认使用 <code>--mixed</code> 。</p>
<ul>
<li><code>git reset --mixed</code>：回退到指定版本，工作区文件内容保持不变，但是会删除暂存区。</li>
<li><code>git reset --soft</code>：回退到指定的版本，保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区。</li>
<li><code>git reset --hard</code>： 撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到指定版本。</li>
</ul>
<h4 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h4><p><code>git log</code> 可以查看已经提交的日志记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit eaf922fa1908cb6e9295570252ce3776f851bc16 (HEAD -&gt; master, dev)</span><br><span class="line">Author: junhaideng &lt;201648748@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 17 19:21:53 2021 +0800</span><br><span class="line"></span><br><span class="line">    docs: add README.md</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">7110de5 (HEAD -&gt; master) docs: add README.md</span><br></pre></td></tr></table></figure>



<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p><code>git branch &lt;branch name&gt;</code> 或者 <code>git checkout -b &lt;branch name&gt;</code> 都可以创建分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch1</span><br><span class="line">Switched to a new branch <span class="string">&#x27;branch1&#x27;</span></span><br><span class="line">$ git branch branch2</span><br><span class="line">Switched to a new branch <span class="string">&#x27;branch2&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p><code>git checkout &lt;branch name&gt;</code> 或者 <code>git switch &lt;branch name&gt;</code>，使用 <code>git checkout -</code> 可以切换到上一次所在的分支哦</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout branch1</span><br><span class="line">Switched to branch <span class="string">&#x27;branch1&#x27;</span></span><br><span class="line">$ git switch branch2</span><br><span class="line">Switched to branch <span class="string">&#x27;branch2&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><p><code>git branch</code> 查看所有的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  branch1</span><br><span class="line">  branch2</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p><code>git branch -d/-D &lt;branch name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -D branch2</span><br><span class="line">Deleted branch branch2 (was eaf922f).</span><br></pre></td></tr></table></figure>



<h4 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h4><p><code>git branch -m/-M &lt;old&gt; &lt;new&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -m branch1 dev</span><br><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p><code>git merge</code> 可以将当前分支和指定分支提交合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* feat/say_hello</span><br><span class="line">  master</span><br><span class="line">$ git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ git merge feat/say_hello</span><br><span class="line">Updating 7110de5..19dad58</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>Git 中标签有两种：</p>
<ul>
<li>轻量标签：<ul>
<li><code>git tag &lt;tag name&gt;</code></li>
<li>不保存其他任何信息，相当于某个提交的信息</li>
</ul>
</li>
<li>附注标签：<ul>
<li><code>git tag -a &lt;tag name&gt;</code></li>
<li>可以显示打标签者的信息，时间和附注消息，然后显示具体的提交信息</li>
</ul>
</li>
</ul>
<p>也可以指定某个提交打标签: <code>git tag xx &lt;commit id&gt;</code></p>
<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><h5 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h5><p><code>git tag -d &lt;tag name&gt;</code> 删除标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line">Deleted tag <span class="string">&#x27;v1.0&#x27;</span> (was 15f051b)</span><br></pre></td></tr></table></figure>

<h5 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag name&gt;</span><br><span class="line">git push origin --delete &lt;tag name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><p><code>git tag</code> 可以显示所有的标签，我们也可以使用 <code>git tag -l/--list</code>，并且可以指定特定模式匹配</p>
<h4 id="显示标签内容"><a href="#显示标签内容" class="headerlink" title="显示标签内容"></a>显示标签内容</h4><p><code>git show &lt;tag name&gt;</code> 可以展示标签对应的提交信息，对于附注标签还可以显示添加的额外信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0 -m <span class="string">&quot;tag demo&quot;</span></span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">$ git show v1.0</span><br><span class="line">tag v1.0</span><br><span class="line">Tagger: junhaideng &lt;201648748@qq.com&gt;</span><br><span class="line">Date:   Sat Dec 18 09:43:27 2021 +0800</span><br><span class="line"></span><br><span class="line">tag demo</span><br><span class="line"></span><br><span class="line">commit 54f9e2cbea36cdd28718a7a0ff847e005442142e (HEAD -&gt; master, tag: v1.0)</span><br><span class="line">Author: junhaideng &lt;201648748@qq.com&gt;</span><br><span class="line">Date:   Fri Dec 17 20:26:25 2021 +0800</span><br><span class="line"></span><br><span class="line">    add: tag</span><br><span class="line"></span><br><span class="line">diff --git a/tag/tag b/tag/tag</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..ce01362</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/tag/tag</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+hello</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="关联仓库"><a href="#关联仓库" class="headerlink" title="关联仓库"></a>关联仓库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般将 name 取为 origin</span></span><br><span class="line"><span class="comment"># url 可以是 ssh,http 等</span></span><br><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure>

<h4 id="拉取最新提交"><a href="#拉取最新提交" class="headerlink" title="拉取最新提交"></a>拉取最新提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只拉取最新提交</span></span><br><span class="line">git fetch </span><br><span class="line"><span class="comment"># 拉取之后合并当前分支</span></span><br><span class="line"><span class="comment"># 相当于 `Git`  fetch + `Git`  merge</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h4 id="推送最新提交"><a href="#推送最新提交" class="headerlink" title="推送最新提交"></a>推送最新提交</h4><p>本地写完代码之后，提交到仓库中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [name] [branch name]</span><br></pre></td></tr></table></figure>



<h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>有时候，我们有些文件不想要提交到仓库中间，比如说编译的中间仓库，那么我们可以创建一个 <code>.gitignore</code> 文件，并且在其中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略 .vscode 目录，无论根目录下的还是子目录下的</span><br><span class="line">.vscode/</span><br><span class="line"># 忽略根目录下的 target 文件夹</span><br><span class="line">/target/</span><br><span class="line"># 忽略所有的 .exe 文件</span><br><span class="line">*.exe</span><br><span class="line"># 指定忽略某个文件</span><br><span class="line">/src/hello.go</span><br><span class="line"># 不过滤 src 目录</span><br><span class="line">!src/</span><br></pre></td></tr></table></figure>

<p>更加详细的见：<a href="https://git-scm.com/docs/gitignore">gitignore</a></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>Git 的提交应该符合一定的规定，这样方便操作，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: &lt;description&gt;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 一般为下面的类型：</p>
<ul>
<li><code>feat</code>: 新功能（feature）</li>
<li><code>fix</code>: 修补bug</li>
<li><code>docs</code>: 文档（documentation）</li>
<li><code>style</code>: 格式（不影响代码运行的变动）</li>
<li><code>refactor</code>: 重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li><code>test</code>: 增加测试</li>
<li><code>chore</code>: 构建过程或辅助工具的变动</li>
<li><code>add</code>: 添加某个文件等</li>
<li><code>change</code>: 对某个文件进行改变，但不改变原来的功能</li>
<li><code>beautify</code>: 对界面进行美化</li>
</ul>
<p>此外也可以参考： <a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交</a></p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><img src="git.png">

<div style="font-size:10; text-align:center">注：图片来自网络</div>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 GitHub Actions 制作定时任务</title>
    <url>/2021/11/22/git/scheduler/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>GitHub Actions</code> 是官方提供的一套 <code>DevOps</code> 工具，可以完成软件开发周期的任务，比如可以实现自动化测试，部署等，简单来理解，我们认为它给我们提供了一个服务器，在上面可以执行一系列的指令(不过会有一些限制)，这就意味着我们可以用来<del>白嫖</del>，比如做定时任务，又不需要自己买服务器。</p>
<p>下面介绍一下如果使用 <code>GitHub Actions</code> 制作一个定时任务，每天定时发布天气情况，当然你学会了之后可以用于签到啊🤭。</p>
<span id="more"></span>

<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>很简单，只要创建一个 <code>GitHub</code> 仓库，不妨叫做 <code>scheduler</code>， 然后将仓库 <code>git clone</code> 到本地编辑器进行编写即可。</p>
<h2 id="逻辑代码实现"><a href="#逻辑代码实现" class="headerlink" title="逻辑代码实现"></a>逻辑代码实现</h2><p>这里我们做一个<strong>天气预报</strong>，每天都可以定时发送天气预报到我们的邮件里面去。</p>
<h3 id="首先第一步，去哪里获取到天气的信息？"><a href="#首先第一步，去哪里获取到天气的信息？" class="headerlink" title="首先第一步，去哪里获取到天气的信息？"></a>首先第一步，去哪里获取到天气的信息？</h3><p>网上有很多天气查询的网站，部分网站提供了对应的 <code>API</code> 接口，但是需要密钥或者限制了调用次数，对于简单的使用来说，比较适合，这里采用爬虫技术从<a href="http://weathernew.pae.baidu.com/weathernew/pc?query=%E6%88%90%E9%83%BD&srcid=4982">百度天气</a>上获取数据，不用受限于密钥和调用次数。</p>
<h3 id="网站资源找到了，如何拉取数据下来？"><a href="#网站资源找到了，如何拉取数据下来？" class="headerlink" title="网站资源找到了，如何拉取数据下来？"></a>网站资源找到了，如何拉取数据下来？</h3><p>一般来说，写爬虫的时候想要获取数据的时候，我们会使用两种方式进行查看：</p>
<ul>
<li>右键查看网页源代码</li>
<li>分析网络请求，F12 即可</li>
</ul>
<p>这里使用第一种方法就可以获取到了，如下为网页源代码，直接包含天气数据：</p>
<img src="source-code.png"  style="width:500px"/>

<p>然后我们可以使用正则表达式，将对应的数据部分获取下来，并且解析为 <code>JSON</code> 数据，大概代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataPattern = regexp.MustCompile(<span class="string">&quot;window.tplData = (.*?);&lt;/script&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略天气数据定义....</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getWeather</span><span class="params">(city <span class="type">string</span>)</span></span> (*WeatherData, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 发送网络请求，获取源代码</span></span><br><span class="line">	resp, err := http.Get(fmt.Sprintf(<span class="string">&quot;http://weathernew.pae.baidu.com/weathernew/pc?query=%s&amp;srcid=4982&quot;</span>, city))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	<span class="comment">// 读取网页源码</span></span><br><span class="line">	data, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 进行匹配，获取数据</span></span><br><span class="line">	match := dataPattern.FindSubmatch(data)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(match) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Do not find weather data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反序列化数据</span></span><br><span class="line">	<span class="keyword">var</span> res WeatherData</span><br><span class="line">	err = json.Unmarshal(match[<span class="number">1</span>], &amp;res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;res, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析之后，我们按照自己的想法拼接信息，然后将数据发送过去即可，这里采用邮件发送，代码如下，当然你可以使用包装更好的一些 <code>package</code>，这里直接使用标准库。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMail</span><span class="params">(to, content <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 这里采用的是 126 邮箱，不同的邮箱 host 设置不同</span></span><br><span class="line">	auth := smtp.PlainAuth(<span class="string">&quot;&quot;</span>, emailUsername, emailPassword, <span class="string">&quot;smtp.126.com&quot;</span>)</span><br><span class="line">	msg := fmt.Sprintf(<span class="string">&quot;From: %s\r\nTo: %s\r\nSubject: %s\r\nContent-Type: %s; charset=UTF-8\r\n\r\n %s&quot;</span>,</span><br><span class="line">		emailUsername,</span><br><span class="line">		to,</span><br><span class="line">		<span class="string">&quot;每日天气&quot;</span>,</span><br><span class="line">		<span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">		content,</span><br><span class="line">	)</span><br><span class="line">	err := smtp.SendMail(<span class="string">&quot;smtp.126.com:25&quot;</span>, auth, emailUsername, []<span class="type">string</span>&#123;to&#125;, []<span class="type">byte</span>(msg))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;send email failed: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的示例，可以进行加工</span></span><br><span class="line"><span class="keyword">const</span> tpl = <span class="string">`&#123;&#123;.city&#125;&#125;天气情况：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">今天是&#123;&#123;.date&#125;&#125;，农历&#123;&#123;.lunar&#125;&#125;，天气&#123;&#123;.weather&#125;&#125;，伴有&#123;&#123;.wind_direction&#125;&#125;，预测今日&#123;&#123;.precipitation_type&#125;&#125;</span></span><br><span class="line"><span class="string">紫外线&#123;&#123;.uv&#125;&#125;, &#123;&#123;.uv_info&#125;&#125;，pm2.5指标为&#123;&#123;.pm25&#125;&#125;, 属于&#123;&#123;.pm25_level&#125;&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	t, err := template.New(<span class="string">&quot;weather&quot;</span>).Parse(tpl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Parse template failed: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf = &amp;strings.Builder&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将数据添加到模板中</span></span><br><span class="line">	err = t.Execute(buf, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;city&quot;</span>:               city,</span><br><span class="line">		<span class="string">&quot;date&quot;</span>:               data.Base.Date,</span><br><span class="line">		<span class="string">&quot;lunar&quot;</span>:              data.Base.Lunar,</span><br><span class="line">		<span class="string">&quot;weather&quot;</span>:            data.Weather[<span class="string">&quot;weather&quot;</span>],</span><br><span class="line">		<span class="string">&quot;wind_direction&quot;</span>:     data.Weather[<span class="string">&quot;wind_direction&quot;</span>],</span><br><span class="line">		<span class="string">&quot;uv&quot;</span>:                 data.Weather[<span class="string">&quot;uv&quot;</span>],</span><br><span class="line">		<span class="string">&quot;uv_info&quot;</span>:            data.Weather[<span class="string">&quot;uv_info&quot;</span>],</span><br><span class="line">		<span class="string">&quot;precipitation_type&quot;</span>: data.Weather[<span class="string">&quot;precipitation_type&quot;</span>],</span><br><span class="line">		<span class="string">&quot;pm25&quot;</span>:               data.PSPm25.PSPm25,</span><br><span class="line">		<span class="string">&quot;pm25_level&quot;</span>:         data.PSPm25.Level,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	sendMail(to, buf.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定时任务设置"><a href="#定时任务设置" class="headerlink" title="定时任务设置"></a>定时任务设置</h2><p>定时任务是这次的重点，设置起来其实也挺简单的。</p>
<p>首先我们需要创建文件夹 <code>.github/workflows</code>，文件夹下面可以创建工作流程文件，只要是 <code>.yml</code> 文件都会作为一个单独的工作流程文件，每一个文件都会在事件触发的时候执行，比如在提交代码，提PR的时候等。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如仅在push的时候执行</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="comment"># push 或者 pull_request 的时候执行</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br><span class="line"><span class="comment"># 同时也可以指定分支</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>更加具体的语法可以参加<a href="https://docs.github.com/en/actions">官方文档</a>介绍，这里不再赘述，如果我们想要定义一个定时任务，那么触发事件可以类比下面的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span>  <span class="string">&#x27;30 5,17 * * *&#x27;</span> <span class="comment"># 每天5:30, 17:30执行，时间为国际标准时间，非北京时间！！</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>cron</code> 语法和 <code>Linux</code> 中的一致，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────── 分钟 (0 - 59)</span><br><span class="line">│ ┌───────────── 小时 (0 - 23)</span><br><span class="line">│ │ ┌───────────── 日期 (1 - 31)</span><br><span class="line">│ │ │ ┌───────────── 月 (1 - 12 or JAN-DEC)</span><br><span class="line">│ │ │ │ ┌───────────── 星期 (0 - 6 or SUN-SAT)</span><br><span class="line">│ │ │ │ │</span><br><span class="line">│ │ │ │ │</span><br><span class="line">│ │ │ │ │</span><br><span class="line">* * * * *</span><br></pre></td></tr></table></figure>

<p>如果你不清楚输出的表示什么时间，那么你可以在 <a href="https://crontab.guru/">crontab guru</a> 中进行测试。而对于我们的天气预报来说，我们的工作流程文件可以定义为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">weather-report</span> <span class="comment"># 工作流程名称，会在网页中进行显示</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span>  <span class="comment"># 为了调试方便，修改代码之后push上去即可以看到效果</span></span><br><span class="line">    <span class="attr">paths:</span> <span class="comment"># 指定只有哪些文件修改了才会触发该工作流程</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">weather-report/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.github/workflows/weather-report.yml</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># 定时任务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 0 * * *&quot;</span> <span class="comment"># 每天 0 点跑 =&gt; 东八区 8点</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">weather-report:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">&quot;ubuntu-latest&quot;</span> <span class="comment"># 在什么机器上跑</span></span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置的一些 secret，在 settings 中可以设置</span></span><br><span class="line">      <span class="attr">EMAIL_USERNAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.EMAIL_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">EMAIL_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.EMAIL_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">TO:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.TO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">steps:</span> <span class="comment"># 指定的步骤</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-go@v2</span>  <span class="comment"># 使用 golang </span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="string">&quot;^1.17&quot;</span> <span class="comment"># 版本号</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">go</span> <span class="string">run</span> <span class="string">weather-report/main.go</span> <span class="string">-eu</span> <span class="string">$EMAIL_USERNAME</span> <span class="string">-ep</span> <span class="string">$EMAIL_PASSWORD</span> <span class="string">-to</span> <span class="string">$TO</span>  <span class="comment"># 指定的命令</span></span><br></pre></td></tr></table></figure>

<p>所有代码编写完成之后，push 到仓库中，便可以查看到正在执行的行为。</p>
<img width=500 src="actions.png" >

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>核心步骤其实很简单：</p>
<ul>
<li>创建仓库，<code>clone</code> 下来</li>
<li>进行逻辑代码编写</li>
<li>创建 <code>.github/workflows</code> 目录，并编写工作流程文件</li>
<li><code>push</code> 代码上去，事件触发时执行</li>
</ul>
<p>工作流程文件的编写并不是很复杂，如果我们会 <code>docker-compose.yml</code> 的编写，很容易就掌握了基本内容，其他需要的语法到时候翻翻官方文档即可，而且官方提供了大量的模板供使用。</p>
<p>上述的这个定时任务并没有什么很大的使用之处，毕竟人手一台手机，天气点一点就是知道的事了，比这个方便美观多了，其实更重要是学习怎么利用爬虫去获取简单的数据，以及 <code>GitHub Actions</code> 的使用，如果把签到作为定时任务，那么定会得到极大的解放🧐。</p>
<p>不过，<code>GitHub Actions</code> 的使用当然不仅限于此，自动化测试，自动化部署都可以通过它实现~</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub Actions</tag>
        <tag>Scheduler</tag>
      </tags>
  </entry>
  <entry>
    <title>动手写一个 HTTP 正向代理</title>
    <url>/2021/12/06/network/http-proxy/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先我们来了解一下 <code>HTTP</code> 代理的相关概念，通常来说，有两类 <code>HTTP</code> 代理，一类是<code>正向代理</code>，一类是<code>反向代理</code>，虽都是代理，但仍有区别。</p>
<p>我们平时使用的 <code>VPN</code> 就是正向代理，我们<strong>指定一个服务器</strong>，然后通过正向代理去连接这个服务器获取资源</p>
<span id="more"></span>

<img src="forward.svg">

<p><code>Nginx</code> 是典型的反向代理服务器，可以用于负载均衡和缓存，我们<strong>不清楚服务器的地址</strong>，但是我们访问反向代理服务器的时候，它会自动为我们请求服务器，并且返回相应的内容。</p>
<img src="reverse.svg">

<blockquote>
<p>总结：正向代理下，我们知道服务器的具体地址，反向代理下，我们只需要知道代理服务的地址，无需知道具体的服务端地址。</p>
</blockquote>
<p>这里，我们讲述正向代理，首先先来简单的回忆一下 HTTP 协议吧，也可以参考之前的 <a href="http://mp.weixin.qq.com/s?__biz=MzAwNDM4NTU0MA==&mid=2247484211&idx=1&sn=8fb8b397184d75b215e5961a23804b76&chksm=9b2dfd58ac5a744e782c56ed22eb50d599639f89c2b323ae8cb71e0328c5a7042640e4bd0590#rd">文章</a></p>
<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>HTTP 基于传输层协议而搭建的应用层协议，其实 HTTP 请求和响应没有什么很神奇的部分，就是一个 <code>Client/Server</code> 模型，客户端通过套接字发送数据，服务端解析之后进行处理，然后返回响应。</p>
<p>这里只稍微介绍一下协议格式，想要了解更多的同学可以参考 <a href="https://www.rfc-editor.org/info/rfc2068">HTTP/1.1</a>，下面的内容均通过 <code>wireshark</code> 抓包获得。</p>
<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>格式如下：</p>
<img src="request.png" height=200>

<p>每一行均以 <code>\r\n</code> 结尾，请求体可以为空</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>格式如下：</p>
<img src="response.png" >

<p>每一行也是以 <code>\r\n</code> 结尾，响应体可以为空</p>
<blockquote>
<p>请求和响应在格式上的主要区别在第一行，也就是请求行和响应行的内容不一致，此外，请求和响应的头部取值也有所区别，部分头部只用于请求，部分头部只由于响应，但是常见的绝大多数头部在响应和请求中均可使用。</p>
</blockquote>
<p>我们如果要构造一个请求也很简单，创建一个套接字，然后发送上述格式的数据即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;httpbin.org:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Dial tcp err: &quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造请求</span></span><br><span class="line">msg := strings.Builder&#123;&#125;</span><br><span class="line">msg.WriteString(<span class="string">&quot;GET /get HTTP/1.1\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;Host: httpbin.org\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;Accept: application/json\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;Connection: close\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送内容</span></span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(msg.String()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Send msg err: &quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，响应也是，这里不再赘述，读者可自行编写代码，也可以使用 <code>wireshark</code> 抓包测试。</p>
<h2 id="正向代理实现"><a href="#正向代理实现" class="headerlink" title="正向代理实现"></a>正向代理实现</h2><p>上面提到过，在正向代理下，我们会首先连接到代理服务器，然后代理服务会到服务器上请求对应的资源，那么我们身为代理服务器，如何知道客户端需要请求什么资源呢？</p>
<p>这到不同担心，客户端连接代理的时候，是有一定的规范的，不是说随便连，对于 <code>HTTP</code> 协议来说，请求代理服务器和请求普通的服务器大致相同，但是请求的路径一般会设置为绝对路径，比如为 <code>GET http://httpbin.org/ HTTP/1.1</code>，而不是 <code>GET / HTTP/1.1</code>，对于 <code>HTTPS</code> 来说，首先会通过 <code>CONNECT</code> 连接到代理服务器，接受到 <code>200</code> 响应之后才会发送实际的加密数据。</p>
<p>首先我们来考虑一下 <code>HTTP</code> 吧，下面是连接到服务器上的请求：</p>
<img src="proxy_1.png">

<p>我们需要做的是获取到对应的服务器地址，也就是 <code>Host</code> 字段，将头部数据解析完成之后，获取该字段即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Method  <span class="type">string</span></span><br><span class="line">	Path    <span class="type">string</span></span><br><span class="line">	Version <span class="type">string</span></span><br><span class="line">	Headers http.Header</span><br><span class="line">	Body    []<span class="type">byte</span></span><br><span class="line">	raw     []<span class="type">byte</span>  <span class="comment">// 原始请求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Request)</span></span> Host() (<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Headers.Get(<span class="string">&quot;Host&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r.Headers.Get(<span class="string">&quot;Host&quot;</span>), <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseRequest</span><span class="params">(conn io.Reader)</span></span> (*Request, <span class="type">error</span>) &#123;</span><br><span class="line">	br := bufio.NewReader(conn)</span><br><span class="line">	<span class="comment">// ...省略部分代码...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析请求头部</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := br.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		req.raw = <span class="built_in">append</span>(req.raw, line...)</span><br><span class="line">		line = bytes.TrimSpace(line)</span><br><span class="line">		<span class="comment">// \r\n</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		colon := bytes.IndexByte(line, <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="comment">// Bytes2Str 将 []byte 转换成 string</span></span><br><span class="line">		req.Headers.Add(byteconv.Bytes2Str(bytes.TrimSpace(line[:colon])), byteconv.Bytes2Str(bytes.TrimSpace(line[colon+<span class="number">1</span>:])))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...省略部分代码...</span></span><br><span class="line">    <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到服务端的地址之后，建立 <code>TCP</code> 连接，然后将请求发送过去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !strings.Contains(host, <span class="string">&quot;:&quot;</span>) &#123;</span><br><span class="line">	host += <span class="string">&quot;:80&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    conn.Close()</span><br><span class="line">    log.Println(<span class="string">&quot;Dial server failed: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = server.Write(request.Raw())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;Write server failed: &quot;</span>, err)</span><br><span class="line">    conn.Close()</span><br><span class="line">    server.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将响应返回给客户端，直接调用 <code>io.Copy</code> 即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tunnel(conn, server)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnel</span><span class="params">(client net.Conn, server net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> io.Copy(server, client)</span><br><span class="line">	<span class="keyword">go</span> io.Copy(client, server)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果说，我们想对响应进行过滤或者其他的操作，我们应该进行解析，解析的过程和请求类似，如果需要过滤掉，则不将结果返回，返回一些错误码，比如 403 即可。</p>
</blockquote>
<p>对于 <code>HTTPS</code> 协议来说其实也是差不多的，但是由于 HTTPS 采用 <code>SSL/TLS</code> 对数据进行加密，所以我们无法对其实际的请求进行解析，不过对 <code>CONNECT</code> 请求进行解析已经可以满足我们的需求了。</p>
<p>接受到 <code>CONNECT</code> 请求之后，我们首先应该返回 <code>2xx</code> 表示连接成功，然后将请求的数据原封不动的发送给服务端，服务端返回的也原封不动的返回给客户端，我们对其中的数据不关心，即使关心也解密不了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.Method ==  <span class="string">&quot;CONNECT&quot;</span>&#123;</span><br><span class="line">    conn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>))</span><br><span class="line">    tunnel(conn, server)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><p>下载插件 <code>Proxy SwitchyOmega</code>，如果你使用 <code>Edge</code>，见 <a href="https://microsoftedge.microsoft.com/addons/detail/proxy-switchyomega/fdbloeknjpnloaggplaobopplkdhnikc">这里</a>，如果你使用Google，见 <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">这里</a></p>
<p>打开插件进行配置，如下<br><img src="SwitchyOmega.png" width=500></p>
<p>访问一个网址，比如<code>http://httpbin.org</code>，如果可以访问，那么说明代理服务器生效~</p>
<p>完整代码见 <a href="https://github.com/junhaideng/go-http-proxy">GitHub</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 协议简介</title>
    <url>/2021/07/03/network/http/</url>
    <content><![CDATA[<h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p><code>HTTP</code> 是 <code>Hypertext Transfer Protocol</code> 的缩写，也就是超文本标记协议，多数的 HTTP 协议运行在 TCP 上，新型的 HTTP3 协议运行在 UDP 上。</p>
<p>简单来说，HTTP 协议就是一个 <code>客户端与服务端</code> 通信的协议，客户端发送数据给服务端，那么服务端要认识这些数据表示什么，服务端返回给客户端的数据，客户端也要认识这些数据</p>
<span id="more"></span>

<img src="cs.svg">

<h2 id="HTTP发展"><a href="#HTTP发展" class="headerlink" title="HTTP发展"></a>HTTP发展</h2><p>HTTP其实诞生也不过30多年，但是对人类的影响是巨大的，随着技术的不断发展进步，HTTP协议也在不断地完善和改进</p>
<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>最古老的 HTTP 协议并不是 HTTP/1.0，而是 HTTP/0.9，但是 HTTP/0.9 并没有成为标准，也没有进行大规模的使用。<br>HTTP/0.9 的组成极其简单，对于客户端，仅仅支持 <code>GET</code> 方法，服务端也只能返回 <code>HTML</code> 文本内容</p>
<img src="http_0.9.svg">

<p>HTTP/0.9 协议不能满足实际需求，也仅仅在实验室中使用</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>1996年， HTTP/1.0 公布，HTTP/1.0 在 HTTP/0.9 的基础上进行了多方面的扩展，完善了请求行信息，添加了请求头部，响应内容也支持头部信息，和目前的协议格式基本一致</p>
<img src="http_1.0.svg">

<p>并且开始支持三个请求方法:</p>
<ul>
<li><code>POST</code>: 向服务端发送数据</li>
<li><code>GET</code>: 用来请求对应的资源</li>
<li><code>HEAD</code>: 用于获取响应头部信息，与 <code>GET</code> 十分类似，但是没有响应主体</li>
</ul>
<p>HTTP/1.0 默认使用的是短连接，也就是说，每一次向服务端请求一次资源，便需要重新创建一个新的 socket，向服务端请求数据，然后关闭 socket。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>在 HTTP/1.0 发布没几个月，1997年，HTTP/1.1 也正式公布了，并且成为第一个标准化的 HTTP 协议。</p>
<p>HTTP/1.1 中默认开启长连接，也就是指定头部的  Connection:keep-alive  ，使用长连接的好处就是可以减少 socket 创建的消耗，因为创建一个 socket 需要进行系统调用，这个需要消耗比较多的资源。</p>
<img src="HTTP-vs-with-Push-HTTP1.gif">


<p>此外HTTP/1.1中增加了一系列其他的请求方法，比如 <code>PUT</code>,<code>DELETE</code>,<code>OPTIONS</code> 等等，并且可以使用头部的 <code>Cache-Control</code> 控制资源的缓存。</p>
<p>HTTP/1.1 在互联网中广泛使用，现在仍然有很多网站在使用 <code>HTTP/1.1</code>，我们可以使用 <code>wireshark</code> 进行抓包分析</p>
<img src="wireshark.png">

<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>HTTP/1.1 得到广泛使用，但是随着使用时间的越来越长，也暴露出了不少了的问题，比如说发送的内容都是明文字符，容易被第三方截获造成消息的泄露，在 HTTP/2 中采用了 <code>SSL/TLS</code> 协议，对数据进行加密，提高数据传输过程中的安全性，不过数据的加密需要较多的CPU资源和时间。</p>
<p>HTTP/1.1 在 <code>socket</code> 利用率方面还是有所缺陷，HTTP/2 中提出了 <code>多路复用</code> 机制，能够同时发送多个 HTTP 请求，然后服务端返回多个响应，如下图：</p>
<img src="HTTP-vs-with-Push-HTTP2.gif">

<p>由于HTTP头部信息内容比较大，并且在很多时候发送的HTTP请求头部都有一部分的重复，HTTP/2中采用头部压缩技术 <code>HPACK</code>，使用字典对头部信息进行保存，这样下一次发送的时候就可以只发送对应的键就好了，大大压缩的头部消息。</p>
<p>HTTP/2 还支持 <code>服务端推送</code>，服务端在客户端请求资源的时候可以推断下一次客户端可能需要的资源，发送给客户端缓存到本地，下一次使用的时候可以直接使用缓存中的资源，当然客户端也可以拒绝服务端推送的资源。</p>
<img src="HTTP-vs-with-Push-HTTP2push.gif">


<h2 id="实现简单的HTTP客户端和服务端"><a href="#实现简单的HTTP客户端和服务端" class="headerlink" title="实现简单的HTTP客户端和服务端"></a>实现简单的HTTP客户端和服务端</h2><p>其实服务端和客户端的沟通就是通过 socket 进行连接，然后通过发送的数据和解析数据，客户端和服务端便可以互相理解，从而做出对应的动作，这里为了简单，使用 HTTP/1.1 协议作为讲解，请求网站 <code>http://httpbin.org</code></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>根据我们上面的理解，客户端请求数据的时候有一个请求行和一个请求头部，我们只需要满足这个条件，便可以模拟浏览器发送一个 <code>HTTP</code> 请求了。</p>
<p>首先我们先与服务端建立连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用host:port形式</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;httpbin.org:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Dial tcp err: &quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure>

<p>然后构建HTTP请求数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := strings.Builder&#123;&#125;</span><br><span class="line">msg.WriteString(<span class="string">&quot;GET /get HTTP/1.1\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;Host: httpbin.org\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;Accept: application/json\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;Connection: close\r\n&quot;</span>)</span><br><span class="line">msg.WriteString(<span class="string">&quot;\r\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>接着将数据发送到服务端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = conn.Write([]<span class="type">byte</span>(msg.String()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Send msg err: &quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后读取服务端返回的数据即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">buf := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  msg, err := buf.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">      <span class="keyword">break</span> </span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Read err: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Print(<span class="string">&quot;Receive: &quot;</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>对于服务端来说，我们需要解析客户端请求的数据，然后进一步做出响应，这里为了简单，仅仅向客户端显示一个 <code>Hello World</code> 字符串。</p>
<p>首先我们需要监听一个端口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8888&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Listen err: &quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后接收客户端的请求，得到一个与客户端的连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  conn, err := listener.Accept()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Accept err: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于每一个连接，起一个goroutine进行处理</span></span><br><span class="line">  <span class="keyword">go</span> handle(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后向连接中写入HTTP响应格式的数据即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	msg := strings.Builder&#123;&#125;</span><br><span class="line">	msg.WriteString(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>)</span><br><span class="line">	msg.WriteString(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	msg.WriteString(<span class="string">&quot;Hello World\r\n&quot;</span>)</span><br><span class="line">	msg.WriteString(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	conn.Write([]<span class="type">byte</span>(msg.String()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>curl</code>命令请求便可以获取到对应的响应信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8888</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 参数设置默认值</title>
    <url>/2022/07/27/rust/default/</url>
    <content><![CDATA[<h2 id="Option-模式？"><a href="#Option-模式？" class="headerlink" title="Option 模式？"></a>Option 模式？</h2><p>在调用函数的时候，可能参数比较多，但是我们只需要修改其中的几个特定参数就可以满足我们的需求，而其他的参数我们希望保持不变，但是 Rust 和 Go 一样，函数调用中不支持默认参数，所以我们必须另寻他法，那么第一感觉我们是不是可以采用 Go 中的 <a href="/2021/07/13/golang/options/" target="_blank">选项模式</a>呢？</p>
<p>虽然 Rust 函数中并不支持变参数传递，但是我们可以通过 <code>宏</code> 来间接达到相同的功能，代码如下</p>
<span id="more"></span>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    host: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">i16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            host: <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            port: <span class="number">8888</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> NewServer &#123;</span><br><span class="line">    ( $($f:ident), *) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Server &#123;</span><br><span class="line">            ..<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        $(</span><br><span class="line">            $<span class="title function_ invoke__">f</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">        )*</span><br><span class="line"></span><br><span class="line">        s</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只要传递函数给宏，函数中修改参数的指即可，但是我们如何将函数传递进去呢，这里我们采用 <code>FnOnce</code> 闭包函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">with_host</span>(host: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;<span class="keyword">mut</span> Server) &#123;</span><br><span class="line">    <span class="keyword">move</span> |server| server.host = host</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">with_port</span>(port: <span class="type">i16</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;<span class="keyword">mut</span> Server) &#123;</span><br><span class="line">    <span class="keyword">move</span> |server| server.port = port</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的时候不太方便，因为宏中不支持使用括号，所以必须使用下面的方式进行调用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">with_host</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;0.0.0.0&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = <span class="title function_ invoke__">with_port</span>(<span class="number">8000</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = NewServer![f, f2];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在 Rust 中实际上并不支持函数重载，但是通过宏，我们可以达到类似的效果，但同时由于宏的替换方式，所以我们无法通过判断变量的类型，然后动态返回结果</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    host: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">i16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> NewServer &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        Server &#123;</span><br><span class="line">            host: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">            port: <span class="number">8080</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ($var: expr) =&gt; &#123;</span><br><span class="line">        Server &#123;</span><br><span class="line">            host: <span class="type">String</span>::<span class="title function_ invoke__">from</span>($var),</span><br><span class="line">            port: <span class="number">8080</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    (_, $var: expr) =&gt; &#123;</span><br><span class="line">        Server &#123;</span><br><span class="line">            host: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">            port: $var,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = NewServer!();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = NewServer!(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = NewServer!(_, <span class="number">8888</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="手动实现-setter"><a href="#手动实现-setter" class="headerlink" title="手动实现 setter"></a>手动实现 setter</h2><p>创建对象的时候返回一个结构体，然后提供 <code>setter</code> 方法进行配置。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    host: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">i16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            host: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">            port: <span class="number">8888</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">host</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, host: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.host = host.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">port</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, port: <span class="type">i16</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.port = port;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_new_server</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">server</span> = Server::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">host</span>(<span class="string">&quot;0.0.0.0&quot;</span>).<span class="title function_ invoke__">port</span>(<span class="number">8080</span>); </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, server); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-crate"><a href="#使用-crate" class="headerlink" title="使用 crate"></a>使用 crate</h2><p>自己手动写了一个 <code>derive macro</code>，可以自动生成 <code>getter</code> 和 <code>setter</code>，代码仓库见 <a href="https://github.com/junhaideng/construct">construct</a>，在 <code>Cargo.toml</code> 中进行引入：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">construct</span> = &#123;git = <span class="string">&quot;https://github.com/junhaideng/construct&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建结构体的时候添加 <code>derive(Constructor)</code> 即可，详细使用方式见代码仓库说明。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> server &#123;</span><br><span class="line">    <span class="keyword">use</span> construct::Constructor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug, Constructor)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">        <span class="meta">#[cons(setter = false, rename_getter = get_host)]</span></span><br><span class="line">        host: <span class="type">String</span>,</span><br><span class="line">        <span class="meta">#[cons(getter = false, rename_setter = set_server_port)]</span></span><br><span class="line">        port: <span class="type">u16</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                host: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">                port: <span class="number">8080</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::server::Server;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = Server::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;host: &#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">get_host</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not implement because rename</span></span><br><span class="line">    <span class="comment">// println!(&quot;port: &#123;&#125;&quot;, s.port());</span></span><br><span class="line">    s.<span class="title function_ invoke__">set_server_port</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Builder-模式"><a href="#Builder-模式" class="headerlink" title="Builder 模式"></a>Builder 模式</h2><p>与之类似的方式，其实我们也可以通过 <code>Builder</code>(创建者) 模式达到相同的功能。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    host: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    host: <span class="type">String</span>,</span><br><span class="line">    port: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">host</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, host: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.host = host.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">port</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, port: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.port = port;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Server &#123;</span><br><span class="line">        Server &#123;</span><br><span class="line">            host: <span class="keyword">self</span>.host,</span><br><span class="line">            port: <span class="keyword">self</span>.port,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            host: <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            port: <span class="number">8080</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 常见命令及其对应的含义</title>
    <url>/2023/09/03/tools/vim/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>command</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>移动到下一个 word[^1] 的开头</td>
</tr>
<tr>
<td>e</td>
<td>移动到下一个 word 的结尾</td>
</tr>
<tr>
<td>W</td>
<td>移动到下一个 WORD 的开头</td>
</tr>
<tr>
<td>E</td>
<td>移动到下一个 WORD 的结尾</td>
</tr>
<tr>
<td>b</td>
<td>移动到上一个 word 的开头</td>
</tr>
<tr>
<td>B</td>
<td>移动到上一个 WORD 的开头</td>
</tr>
<tr>
<td>ge</td>
<td>移动到上一个 word 的结尾</td>
</tr>
<tr>
<td>gE</td>
<td>的移动到上一个 WORD 的结尾</td>
</tr>
<tr>
<td>f{char}[^2]</td>
<td>移动到<strong>当前行</strong>下一个 <code>char</code> 出现的位置</td>
</tr>
<tr>
<td>F{char}</td>
<td>移动到<strong>当前行</strong>上一个 <code>char</code> 出现的位置</td>
</tr>
<tr>
<td>t{char}</td>
<td>移动到当前行下一个  <code>char</code> 出现的前一个位置</td>
</tr>
<tr>
<td>T{char}</td>
<td>移动到当前行上一个 <code>char</code> 出现的前一个位置</td>
</tr>
<tr>
<td>0</td>
<td>移动到当前行的第一个字符位置</td>
</tr>
<tr>
<td>^</td>
<td>移动到当前行的第一个非空字符的位置</td>
</tr>
<tr>
<td>$</td>
<td>移动到当前行的最后一个位置</td>
</tr>
<tr>
<td>g_</td>
<td>移动到当前行的最后一个非空字符的位置</td>
</tr>
<tr>
<td>{</td>
<td>移动到下一个段落</td>
</tr>
<tr>
<td>}</td>
<td>移动到上一个段落</td>
</tr>
<tr>
<td>/{pattern}</td>
<td>搜索下一个符合的单词[^3]</td>
</tr>
<tr>
<td>?{pattern}</td>
<td>搜索上一个符合的单词</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文件的最上方</td>
</tr>
<tr>
<td>{line}gg</td>
<td>移动到指定的行数</td>
</tr>
<tr>
<td>G</td>
<td>移动到文件的末尾</td>
</tr>
<tr>
<td>%</td>
<td>移动到匹配 <code>(&#123;[]&#125;)</code> 的位置[^4]</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>D</td>
<td>删除到结尾的字符，相当于 <code>d$</code></td>
</tr>
</tbody></table>
<span id="more"></span>


<p>使用 {count}{command} 效果相当于同时执行 count 个 command 命令，比如 <code>5j</code> 相当于往下移动 5 行.</p>
<p>[^1]: 比如 <code>words.</code>，使用 word 表示的话，可以分成两个，<code>word</code> + <code>.</code>，但是如果使用 WORD 表示的话，则是一个。<br>[^2]: 执行完命令之后，可以使用 <code>;</code> 到下一个 <code>char</code> 出现的位置，使用 <code>,</code> 到上一个位置。<br>[^3]: 使用回车进行确认，<code>n</code> 移动到下一个匹配的位置，<code>N</code> 移动到上一个匹配的位置。<br>[^4]: 如果是 ({[ 则移动到 )}]，否则反之。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 dlv 进行 debug</title>
    <url>/2022/11/16/golang/dlv/</url>
    <content><![CDATA[<p>使用 <code>dlv</code> 可以方便的对 <code>go</code> 生成的二进制文件进行 <code>debug</code>，以下面的代码 <code>main.go</code> 为例讲解 <code>dlv</code> 的使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	q := r.URL.Query().Get(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> q != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;search query: %s\n&quot;</span>, q)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello World! %s&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, Hello)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h3 id="1️⃣-安装-dlv"><a href="#1️⃣-安装-dlv" class="headerlink" title="1️⃣ 安装 dlv"></a>1️⃣ <strong>安装 dlv</strong></h3><p>直接使用 <code>go install</code> 命令即可将 <code>dlv</code> 安装到 <code>$GOPATH/bin</code> 目录下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以下载最新的</span></span><br><span class="line">go install github.com/go-delve/delve/cmd/dlv@latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以下载指定的版本</span></span><br><span class="line">go install github.com/go-delve/delve/cmd/dlv@v1.7.3</span><br></pre></td></tr></table></figure>


<h3 id="2️⃣-编译代码，设置编译参数"><a href="#2️⃣-编译代码，设置编译参数" class="headerlink" title="2️⃣ 编译代码，设置编译参数"></a>2️⃣ <strong>编译代码，设置编译参数</strong></h3><p>直接使用 <code>go build</code> 编译二进制文件的时候，会对代码进行优化和内联，导致使用 <code>dlv</code> 的时候部分命令不能使用，比如函数的调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存在优化的编译</span></span><br><span class="line">go build -o http_server main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉编译优化</span></span><br><span class="line">go build -gcflags=<span class="string">&quot;all=-N -l&quot;</span> -o http_server main.go</span><br></pre></td></tr></table></figure>


<h3 id="3️⃣-dlv-exec-path-to-bin，进入调试模式"><a href="#3️⃣-dlv-exec-path-to-bin，进入调试模式" class="headerlink" title="3️⃣ dlv exec path/to/bin，进入调试模式"></a>3️⃣ <strong>dlv exec path/to/bin，进入调试模式</strong></h3><p>使用 <code>exec</code> 子命令，直接调试可运行的二进制文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dlv exec ./http_server</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) </span><br></pre></td></tr></table></figure>

<h3 id="4️⃣-比对文件路径和行数，设置对应的断点"><a href="#4️⃣-比对文件路径和行数，设置对应的断点" class="headerlink" title="4️⃣ 比对文件路径和行数，设置对应的断点"></a>4️⃣ <strong>比对文件路径和行数，设置对应的断点</strong></h3><p>比如我想在 <code>main.go</code> 的 <code>Hello</code> 函数进行调试，定位这个函数的行数为第 <code>9</code> 行，路径为 <code>main.go</code>，然后可以执行 <code>break main.go:9</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) break main.go:9</span><br><span class="line">Breakpoint 1 set at 0x6e1bef for main.Hello() ./main.go:9</span><br></pre></td></tr></table></figure>

<p>如果提示 <code>location xxx ambiguous</code>，需要对路径进行明确，使用输出的长路径即可，比如 <code>break github.com/xxx/xxx/main.go</code>。</p>
<p>设置好断点之后，可以通过 <code>breakpoints</code>命令查询所有的断点，可以发现 <code>dlv</code> 默认也会将 <code>panic</code> 加入断点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) breakpoints</span><br><span class="line">Breakpoint runtime-fatal-throw (enabled) at 0x438720 for runtime.throw() /usr/local/go/src/runtime/panic.go:1188 (0)</span><br><span class="line">Breakpoint unrecovered-panic (enabled) at 0x438a80 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1271 (0)</span><br><span class="line">        print runtime.curg._panic.arg</span><br><span class="line">Breakpoint 1 (enabled) at 0x6e1bef for main.Hello() ./main.go:9 (1)</span><br></pre></td></tr></table></figure>

<h3 id="5️⃣-执行程序，直到运行到断点或者程序结束"><a href="#5️⃣-执行程序，直到运行到断点或者程序结束" class="headerlink" title="5️⃣ 执行程序，直到运行到断点或者程序结束"></a>5️⃣ <strong>执行程序，直到运行到断点或者程序结束</strong></h3><p>这一步不能省略！！！ 省略之后无法调试断点，执行 <code>continue</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) continue</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">(dlv) c</span><br></pre></td></tr></table></figure>

<h3 id="6️⃣-进行请求，使其能够执行到断点处"><a href="#6️⃣-进行请求，使其能够执行到断点处" class="headerlink" title="6️⃣ 进行请求，使其能够执行到断点处"></a>6️⃣ <strong>进行请求，使其能够执行到断点处</strong></h3><p>如果请求 ok 了，<code>continue</code> 命令不再阻塞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) continue</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.Hello() ./main.go:9 (hits goroutine(18):1 total:2) (PC: 0x6e1bef)</span></span><br><span class="line">     4:         &quot;fmt&quot;</span><br><span class="line">     5:         &quot;net/http&quot;</span><br><span class="line">     6:         &quot;time&quot;</span><br><span class="line">     7: )</span><br><span class="line">     8:</span><br><span class="line">=&gt;   9: func Hello(w http.ResponseWriter, r *http.Request) &#123; </span><br><span class="line">    10:         q := r.URL.Query().Get(&quot;q&quot;)</span><br><span class="line">    11:         if q != &quot;&quot; &#123;</span><br><span class="line">    12:                 fmt.Printf(&quot;search query: %s\n&quot;, q)  </span><br><span class="line">    13:         &#125;</span><br><span class="line">    14:         fmt.Fprintf(w, &quot;Hello World! %s&quot;, time.Now()</span><br></pre></td></tr></table></figure>
<p>如果出现 <code>warning</code> 是因为二进制文件是经过优化的，编译的时候可以添加 <code>-gcflags=&quot;all=-N -l&quot;</code> 参数去掉该提示。</p>
<h3 id="7️⃣-愉快的进行调试"><a href="#7️⃣-愉快的进行调试" class="headerlink" title="7️⃣ 愉快的进行调试"></a>7️⃣ <strong>愉快的进行调试</strong></h3><p>使用 dlv 提供的命令，进行调试</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>args</td>
<td>当前函数的参数</td>
</tr>
<tr>
<td>step</td>
<td>进入函数/方法中</td>
</tr>
<tr>
<td>next</td>
<td>跳转到下一行代码</td>
</tr>
<tr>
<td>continue/c</td>
<td>运行代码直到下一个断点或者结束</td>
</tr>
<tr>
<td>break/b</td>
<td>设置断点</td>
</tr>
<tr>
<td>breakpoints/bp</td>
<td>所有的断点</td>
</tr>
<tr>
<td>clear xx</td>
<td>清理掉第 xx 个断点</td>
</tr>
<tr>
<td>clearall</td>
<td>清理所有的断点</td>
</tr>
<tr>
<td>locals</td>
<td>输出所有局部变量</td>
</tr>
<tr>
<td>print</td>
<td>输出指定的变量</td>
</tr>
</tbody></table>
<p><code>print</code> 如果需要输出长字符串，可以先执行 <code>config max-string-len 1000</code> 扩大输出的字符串长度</p>
<p>编译时需要禁止优化才能使用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build xxxx -gcflags=<span class="string">&quot;all=-N -l&quot;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>输出源代码</td>
</tr>
<tr>
<td>call</td>
<td>调用函数</td>
</tr>
</tbody></table>
<h3 id="8️⃣-More"><a href="#8️⃣-More" class="headerlink" title="8️⃣ More"></a>8️⃣ <strong>More</strong></h3><p><code>dlv</code> 不仅使用 <code>attach</code> 对正在运行的程序进行调试，也可以直接对二进制文件进行调试 (<code>dlv exec</code>)，甚至是没有编译的代码包 (<code>dlv debug</code>)，更多更详细的文档，可以参考下面的两个链接:</p>
<ul>
<li><a href="https://github.com/go-delve/delve/tree/master/Documentation/usage">dlv 使用手册</a> </li>
<li><a href="https://github.com/go-delve/delve/tree/master/Documentation/cli">dlv 命令文档</a></li>
</ul>
<p>多动手试试，很容易就可以熟悉 <code>dlv</code> 使用~</p>
]]></content>
  </entry>
  <entry>
    <title>Golang 选项模式</title>
    <url>/2021/07/13/golang/options/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Golang不支持在函数定义的时候声明默认值，也就是说我们不能够使用类似下面的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(addr <span class="type">string</span>=&quot;localhost&quot;,  port <span class="type">string</span>=&quot;8080&quot;)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且也不支持函数的重载，函数名不能够重复，无法根据需要的参数数量创建不同的函数形式，也就是我们不能使用下面的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(addr <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次使用同样的函数名会报错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(addr <span class="type">string</span>, port <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="返回默认对象"><a href="#返回默认对象" class="headerlink" title="返回默认对象"></a>返回默认对象</h2><p>那么我们如何才能设置默认值呢？一种很自然的方式比如说，我们创建对象的时候就返回一个带有默认值的对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	Host <span class="type">string</span></span><br><span class="line">	Port <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *myStruct&#123;</span><br><span class="line">  <span class="comment">// 返回一个带有默认值的对象</span></span><br><span class="line">  <span class="keyword">return</span> &amp;myStruct&#123;</span><br><span class="line">    Host: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    Port: <span class="string">&quot;8080&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们如果需要修改参数，那么我们可以手动去修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config := New()</span><br><span class="line"><span class="comment">// 手动修改</span></span><br><span class="line">config.Port = <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的这种方式其实已经可以解决我们的需求，但是还是不够好，因为这种方式会直接<code>暴露</code>结构体中的字段，结构体中的字段名首字母必须大写，并且用户进行修改的时候会直接对字段进行修改，无法对设置的参数进行校验。</p>
<h2 id="Option模式"><a href="#Option模式" class="headerlink" title="Option模式"></a>Option模式</h2><p>下面我们主要讲解 <code>Option模式</code>，也就是 <code>函数选项模式</code>，这种模式下在我们设置默认值的同时支持检验参数。</p>
<p>Option 模式为 Golang 的开发者提供了将一个函数的参数设置为可选的功能，也就是说我们可以选择参数中的某几个，并且可以按任意顺序传入参数。</p>
<p>下面我们来看看具体如何使用：</p>
<p>首先，我们需要设置一个结构体包括我们需要设置的一些参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span>&#123;</span><br><span class="line">  Addr <span class="type">string</span> </span><br><span class="line">  Host <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们需要定义一个<code>Option</code>函数类型可以修改我们的参数结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(c *Config)</span></span></span><br></pre></td></tr></table></figure>

<p>对于我们需要进行修改的参数，我们可以声明对应的函数来修改参数值，这里利用了闭包的特性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithHost</span><span class="params">(host <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Config)</span></span> &#123;</span><br><span class="line">		c.Host = host</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPort</span><span class="params">(port <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Config)</span></span> &#123;</span><br><span class="line">		c.Port = port</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们需要设置一个默认值，如下，也就是用户没有设置任何参数的时候所得到的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultConfig = Config&#123;</span><br><span class="line">	Host: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">	Port: <span class="string">&quot;8080&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，提供一个函数接口，创建对象的时候，用户可以执行一系列的<code>Option</code>来修改默认的参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	host <span class="type">string</span></span><br><span class="line">	port <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(opts ...Option)</span></span> *myStruct &#123;</span><br><span class="line">	<span class="comment">// 默认情况下使用默认参数</span></span><br><span class="line">	config := defaultConfig</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		<span class="comment">// opt 就是一个函数，以 *Config为参数，能够修改其中的内容</span></span><br><span class="line">		opt(&amp;config)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;myStruct&#123;</span><br><span class="line">		host: config.Host,</span><br><span class="line">		port: config.Port,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有另外一种方式实现，思路差不多，直接上代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	host <span class="type">string</span></span><br><span class="line">	port <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个接口类型</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">	apply(*myStruct)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类型，以需要修改的结构体为参数</span></span><br><span class="line"><span class="keyword">type</span> optinFunc <span class="function"><span class="keyword">func</span><span class="params">(*myStruct)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Option接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f optinFunc)</span></span> apply(m *myStruct) &#123;</span><br><span class="line">	f(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithHost</span><span class="params">(host <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> optinFunc(<span class="function"><span class="keyword">func</span><span class="params">(ms *myStruct)</span></span> &#123;</span><br><span class="line">		ms.host = host</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPort</span><span class="params">(port <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> optinFunc(<span class="function"><span class="keyword">func</span><span class="params">(ms *myStruct)</span></span> &#123;</span><br><span class="line">		ms.port = port</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultOne = myStruct&#123;</span><br><span class="line">	host: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">	port: <span class="string">&quot;8080&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(options ...Option)</span></span> *myStruct &#123;</span><br><span class="line">	m := defaultOne</span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">		opt.apply(&amp;m)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以认为我们创建的WithHost, WithPort</span></span><br><span class="line"><span class="comment">// 就是一个可以修改struct字段的函数</span></span><br><span class="line"><span class="comment">// 一般我们会暴露这些函数给使用</span></span><br><span class="line"><span class="comment">// 但是在包内部我们可以修改结构体的私有成员</span></span><br></pre></td></tr></table></figure>


<p>测试结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, New())</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, New(WithHost(<span class="string">&quot;127.0.0.1&quot;</span>)))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, New(WithHost(<span class="string">&quot;127.0.0.1&quot;</span>), WithPort(<span class="string">&quot;8000&quot;</span>)))</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &amp;main.myStruct&#123;host:&quot;0.0.0.0&quot;, port:&quot;8080&quot;&#125;</span></span><br><span class="line"><span class="comment">// &amp;main.myStruct&#123;host:&quot;127.0.0.1&quot;, port:&quot;8080&quot;&#125;</span></span><br><span class="line"><span class="comment">// &amp;main.myStruct&#123;host:&quot;127.0.0.1&quot;, port:&quot;8000&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然说，Option模式在设置参数的时候特别有用，而且显得十分优雅，但是通过对它的实现，我们也知道使用起来相对而言还是比较麻烦，需要添加很多函数</p>
<img src="options.png">

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Language</tag>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希函数</title>
    <url>/2021/12/24/cryptography/signature/hash/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>什么是哈希函数？</strong></p>
<p>定义其实很简单，哈希函数其实就是一种映射关系，它可以把任意长度的数据映射为固定长度的数据，输出一般称为<strong>摘要(digest)</strong> ，就比如常见的 <code>md5</code> 算法，可以将输入映射成 <code>128 bits</code>。</p>
<p>$$\{0, 1\}^* \overset{map}{\longrightarrow} \{0,1\}^n$$</p>
<p>同时，也正因为说，哈希函数将任意长度的输入映射成固定长度的输出，因为输入空间远大于输出空间，所以必然会存在冲突，比如下面的这种情景。不过，在实际使用的时候，必须要求哈希函数具备一定的安全性。</p>
<span id="more"></span>

<img src="map.svg">

<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><blockquote>
<p>以下只是几点比较重要的</p>
</blockquote>
<h3 id="计算-digest-比较快"><a href="#计算-digest-比较快" class="headerlink" title="计算 digest 比较快"></a>计算 digest 比较快</h3><p>因为我们往往需要对大量的数据计算哈希值，如果计算速度慢，会影响整个系统的性能。</p>
<h3 id="抗第一原像"><a href="#抗第一原像" class="headerlink" title="抗第一原像"></a>抗第一原像</h3><p>又称 <code>Preimage resistance</code>。</p>
<p>已知某个哈希值 $y$ 和哈希函数 $H$，找出 $x$ 满足 $H(x) = y$ 在计算上不可行。</p>
<h3 id="抗第二原像性"><a href="#抗第二原像性" class="headerlink" title="抗第二原像性"></a>抗第二原像性</h3><p>又称 <code>Second-preimage resistance</code>。</p>
<p>已知某个输入 $x$ 和哈希函数 $H$，找到 $x^{\prime}$ 满足 $H(x^{\prime}) = H(x)$ 在计算上不可行。</p>
<h3 id="抗碰撞性"><a href="#抗碰撞性" class="headerlink" title="抗碰撞性"></a>抗碰撞性</h3><p>又称 <code>Collision resistance</code>。</p>
<p>已知哈希函数 $H$，找出任意一对 $x^{\prime}, x$， 且 $x^{\prime} \neq x$ 满足 $H(x^{\prime}) = H(x)$，在计算上不可行</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h3><p>网站上的文件，在下载的时候，往往会提供一个摘要来检验文件是否下载完整，比如说下图<a href="https://mirror.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/">^1</a>的 SHA256SUMS 文件</p>
<img src="checksum.png">


<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名有类似书写签名的作用，可以对数据提供<strong>身份校验</strong>以及<strong>完整性校验</strong>。</p>
<p>我们经常访问的 HTTPS 网站均提供了数字证书，为的就是校验这个网站颁发给我们的公钥是不是这个网站的，还是其他人伪造的一个公钥，点击网址签名的小锁 🔒。</p>
<img src="signature.png" style="max-width: 300px;">


<p>进入 <code>Connection is secure</code>，然后点击右上角的证书图标，我们可以看到数字证书中的内容。</p>
<img src="certificate.png" style="max-width: 300px;">


<h2 id="Go-中哈希函数使用示范"><a href="#Go-中哈希函数使用示范" class="headerlink" title="Go 中哈希函数使用示范"></a>Go 中哈希函数使用示范</h2><p>Golang 中提供了许多哈希函数，比如 <code>md5</code>，<code>sha1</code>，<code>sha256</code>，<code>sha512</code> 等，并且通过接口 <code>hash.Hash</code> 暴露，使用起来十分简单，下面以 <code>md5</code> 做示范。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg := []<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">	h := md5.New()</span><br><span class="line">	h.Write(msg)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Sum: %x\n&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line">	<span class="comment">// Sum: b10a8db164e0754105b7a99be72e3fe5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>hash</tag>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash to Obtain Random Subset (HORS)</title>
    <url>/2021/12/25/cryptography/signature/hors/</url>
    <content><![CDATA[<p>HORS(Hash to Obtain Random Subset)属于 FTS, 其生成的公私钥对，可以多次用来签名消息，但是每一次签名之后，系统的安全性会降低，签名能够被伪造的概率上升。论文可见 <a href="hors.pdf">Better than BiBa: Short One-time Signatures with Fast Signing and Verifying</a>。</p>
<p>下面以三元组 $(GEN, SIG, VER)$ 对 HORS 签名系统进行介绍。</p>
<h2 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成($GEN$)"></a>密钥生成($GEN$)</h2><p>$$(pk, sk) \leftarrow GEN(1^k)$$</p>
<p>首先，我们需要确定参数 $k$ 和 $t = 2^\tau$，哈希函数输出的摘要长度为 $n = k \times \log_2t = k \times \tau$ bits。</p>
<span id="more"></span>

<p>这里，我们一般要求 $8\mid \tau$，也就是 $\tau$ 应该是 $8$ 的倍数。</p>
<p>通过 $PRG$ 生成 $t$ 个随机数，构成私钥：</p>
<p>$$sk = (sk_0, sk_1, \dotsm, sk_{t-1})$$</p>
<p>对每一个随机数进行哈希，得到公钥</p>
<p>$$\begin{aligned}<br>  pk &amp;= (pk_0, pk_1, \dotsm, pk_{t-1}) \\ &amp;= (hash(sk_0), hash(sk_1), \dotsm, hash(sk_{t-1}))<br>\end{aligned}$$</p>
<p>图示：</p>
<img src="gen.svg">

<h2 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名($SIG$)"></a>消息签名($SIG$)</h2><p>$$ \sigma(M) \leftarrow SIG(M, sk)$$</p>
<p>对消息 $M\in \{0, 1\}^*$ 进行哈希，得到摘要 $m$。</p>
<p>将 $m$ 进行分割，分成 $k$ 份，每一份 $\tau = \log_2t$ bits，这里如果 $8|\tau$，那么编写程序的时候会得到极大的简化。</p>
<p>$$m = (m_0, m_1, \dotsm, m_{k-1})$$</p>
<p>将每一份转换成对应的整数，比如每份 $16$ bits 时：</p>
<p>$$\begin{aligned}<br>  0001\_0010\_1111\_1000_2 = 4856_{10}<br>\end{aligned}$$</p>
<p>则签名为 </p>
<p>$$\begin{aligned}<br>  \sigma<br>  &amp;= (\sigma_0, \sigma_1, \dotsm, \sigma_{k-1}) \\<br>  &amp;= (sk_{m_0}, sk_{m_1}, \dotsm, sk_{m_{k-1}})<br>\end{aligned} $$</p>
<p>其中有可能<br>$$ \exists \ i, j \in [0, k-1], i \ne j, \sigma_i = \sigma_j $$</p>
<p>图示：<br><img src="sign.svg"></p>
<h2 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验($VER$)"></a>消息校验($VER$)</h2><p>$$ false/true \leftarrow VER(M, \sigma(M), pk) $$</p>
<p>同样，将 $M$ 进行哈希之后，转换成 $k$ 个 $\tau$ bits 的整数</p>
<p>$$m = (m_0, m_1, \dotsm, m_{k-1})$$</p>
<p>计算出</p>
<p>$$ pk^\prime = (pk^\prime_{m_0}, pk^\prime_{m_1}, \dotsm, pk^\prime_{m_{k-1}}) $$</p>
<p>对于 $i \in [0,k-1]$，如果 $hash(\sigma_i) = pk^\prime_i$ 均成立，则校验成功，返回 $true$，否则校验失败，返回 $false$。</p>
<p>图示：</p>
<img src="verify.svg">]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
        <tag>FTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Lamport One Time Signature</title>
    <url>/2021/12/24/cryptography/signature/lamport/</url>
    <content><![CDATA[<p>Lamport 是<strong>第一个</strong> OTS(One Time Signature) 算法，由 <strong>Leslie Lamport</strong> 于 1979 年提出，论文可见 <a href="lamport-ots.pdf" target="_blank"> Constructing Digital Signatures from One Way Function</a> ，一对密钥只能签名一次，不能重复使用。</p>
<p>下面按照 $(GEN, SIG, VER)$ 三元组描述该算法。</p>
<h2 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成($GEN$)"></a>密钥生成($GEN$)</h2><p>$$(pk, sk) \leftarrow GEN(1^k)$$</p>
<p>首先我们需要确定安全参数 $k$，不过实际操作中我们一般只需要确定输出的摘要长度 $n$。</p>
<p>通过随机数生成器(PRG, Pseudo Random Generator)，生成 $n$ 对随机数，每一对包含两个随机数，每一个随机数 $n$ bits，总共 $2\times n\times n$ bits，此为私钥。</p>
<p>对<strong>每一个随机数</strong>进行哈希，生成 $2\times n$ 个摘要，每一个 $n$ bits，也是 $2 \times n \times n$ bits，此为公钥。</p>
<p>形式化表示为：</p>
<p>$$sk = (sk_{0,0}, sk_{0,1}, \dotsm, sk_{n-1, 0}, sk_{n-1, 1}) \\<br>pk = (pk_{0,0}, pk_{0,1}, \dotsm, pk_{n-1, 0}, pk_{n-1, 1})$$</p>
<span id="more"></span>

<p>图示：<br><img src="gen.svg"></p>
<h2 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名($SIG$)"></a>消息签名($SIG$)</h2><p>$$ \sigma(M) \leftarrow SIG(M, sk)$$</p>
<p>对于输入 $M \in \{0, 1\}^*$，首先使用哈希函数进行处理，生成 $n$ bits 的摘要。</p>
<p>$$m = (m_0, m_1, \dotsm, m_{n-1})$$</p>
<p>对于摘要中的每一个 bit，进行下面的操作：对于摘要中的第 $i$ 个 bit $m_i$，如果该 bit 为 0，那么取 $sk_{i,0}$，否则该 bit 位为 1，取 $sk_{i,1}$，最后签名为 </p>
<p>$$\sigma =(\sigma_0, \sigma_1,\dotsm \sigma_{n-1}) = (sk_{0,m_0}, sk_{1,m_1}, \dotsm, sk_{n-1,m_{n-1}})$$</p>
<p>比如说输入的 $M$ 经过哈希之后得到 </p>
<p>$$(0,1,0,1,1,0,0,1)$$</p>
<p>那么签名结果是 </p>
<p>$$\sigma= (sk_{0,0}, sk_{1,1}, sk_{2,0},sk_{3,1},sk_{4,1},sk_{5,0},sk_{6,0},sk_{7,1})$$</p>
<p>图示：<br><img src="sign.svg"></p>
<h2 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验($VER$)"></a>消息校验($VER$)</h2><p>$$ false/true \leftarrow VER(M, \sigma(M), pk) $$</p>
<p>对于消息 $M \in \{0,1\}^*$，首先进行哈希，得到 $n$ bits 的摘要。</p>
<p>$$m = (m_0, m_1, \dotsm, m_{n-1})$$</p>
<p>对于摘要中的每一个 bit，进行下面的操作：对于摘要中的第 $i$ 个 bit $m_i$，如果该 bit 为 0，那么取 $pk_{i,0}$，否则该 bit 位为 1，取 $pk_{i,1}$，最后得到</p>
<p>$$v= (pk_{0,m_0}, pk_{1,m_1}, \dotsm, pk_{n-1,m_{n-1}})$$</p>
<p>对于签名 $\sigma$ 中的每一个部分进行哈希，得到</p>
<p>$$v^{\prime}= (pk_{0,m_0}^{\prime}, pk_{1,m_1}^{\prime}, \dotsm, pk_{n-1,m_{n-1}}^{\prime})$$</p>
<p>如果 $v=v^{\prime}$，则签名校验通过，返回 $true$，否则校验失败，返回 $false$。</p>
<p>图示：<br><img src="verify.svg"></p>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
        <tag>OTS</tag>
      </tags>
  </entry>
  <entry>
    <title>HORS with trees (HORST)</title>
    <url>/2021/12/27/cryptography/signature/horst/</url>
    <content><![CDATA[<p>HORST 属于 FTS，由 HORS 改进而来，相比较 HORS 而言，牺牲了运行时间，但是减少了公钥的大小，同时算法中引入了掩码的计算。</p>
<p>HORST 中的公钥是二叉哈希树 (binary hash tree) 的根节点，叶子节点是 HOSR 公钥的 $(t=2^\tau)$ 个 $block$ 。</p>
<p>本文的介绍建立在 HORS 之上，若还尚未了解 HORS 签名系统机制，可以参考另一篇文章 <a href="/2021/12/25/cryptography/signature/hors/" target="_blank">Hash to Obtain Random Subset (HORS)</a>，此外，提出 HORST 的论文见 <a href="/2021/12/27/cryptography/signature/horst/sphincs.pdf" target="_blank">SPHINCS: practical stateless hash-based signatures</a>。</p>
<span id="more"></span>

<p>下面按照三元组 $(GEN, SIG, VER)$ 介绍该签名算法。</p>
<h2 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成 (GEN)"></a>密钥生成 (GEN)</h2><p>$$pk \leftarrow GEN(\mathcal{S}, \mathcal{Q})$$</p>
<p>首先，我们需要确定参数 $t = 2^\tau$ 和 $k$，且 $t \times k = m$，$m$ 为消息哈希之后的长度，使用哈希函数 $\mathcal{H}$，$n$ 为树中的哈希值长度，使用哈希函数 $\mathcal{F}$。然后求出使得 $k(\tau -x +1) + 2^x$ 最小的 $x$，如果 $x$ 有两个解，取较大的那个。</p>
<p>在 $SPHINCS-256$ 中 </p>
<p>$$t = 2^{16}, k = 32, m = 512, n = 256, x = 6 $$</p>
<p>下面设</p>
<p>$$\mathcal{H}: \{0,1\}^* \rightarrow \{0,1\}^m$$</p>
<p>$$\mathcal{F}: \{0,1\}^* \rightarrow \{0,1\}^n$$</p>
<p>密钥对的生成需要两个输入，一个是随机数种子 $\mathcal{S}\in \{0,1\}^n$，另一个是掩码 $\mathcal{Q} \in \{0,1\}^{2n\times \log t}$。 其中 $\mathcal{Q}$ 可以表示为</p>
<p>$$ \mathcal{Q} = (\mathcal{Q}_{0,0}, \mathcal{Q}_{0,1}, \dotsm, \mathcal{Q}_{\log t-1,0}, \mathcal{Q}_{\log t-1,1}) $$</p>
<p>首先，随机生成 $t$ 个随机数，作为私钥：</p>
<p>$$sk = (sk_0, sk_1, \dotsm, sk_{t-1}) \leftarrow G_t(\mathcal{S}) $$</p>
<p>然后计算</p>
<p>$$L_i = \mathcal{F}(sk_i)$$</p>
<p>作为哈希树的叶子节点，计算出树的根节点，作为公钥，这样的计算公式和 Merkle Tree 不太一样，因为需要计算掩码。 $\mathcal{Q}$ 一共是 $2 \log t$ 个，每一个 $n$ bits，每一层对应一对掩码 $(\mathcal{Q}_{i,0}, \mathcal{Q}_{i,1})$。</p>
<p>$$node_i = \mathcal{F}(node_{2i}\oplus \mathcal{Q}_{i,0}|| node_{2i+1}\oplus \mathcal{Q}_{i,1})$$</p>
<p>左节点使用 $\mathcal{Q}_{i,0}$ 进行异或操作，右结点则使用 $\mathcal{Q}_{i,1}$。</p>
<p>图示：</p>
<img src="gen.svg">


<h2 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名 (SIG)"></a>消息签名 (SIG)</h2><p>$$(\sigma, pk) \leftarrow (M, \mathcal{S}, \mathcal{Q})$$</p>
<p>对于输入的任意消息，首先使用哈希函数 $\mathcal{H}$ 转换成 $M \in \{0,1\}^m$，然后将 $M$ 分成 $k$ 份，每一份 $\log t$ bits。</p>
<p>$$M = (M_0, M_1, \dotsm, M_{k-1})$$</p>
<p>每一份 $M_i, i \in [0, k-1]$ 对应一个整数。</p>
<p>与 HORS 不同的是，HORST 签名 $\sigma$ 包含 $k+1$ 个 $blocks$：</p>
<p>$$\sigma = (\sigma_0, \sigma_1, \dotsm, \sigma_k)$$</p>
<p>对于 $i \in [0,k-1], \sigma_i = (sk_{M_i}, Auth_{M_i})$，其中 $sk_{M_i}$ 的选择方法和 HORS 中一致， $Auth_{M_i}$ 是叶子节点到 $\boldsymbol{\tau -x}$ 层的 <a href="/2021/12/26/cryptography/signature/merkle/#Authentication-path" target="_blank">认证路径</a>，而不是根节点。 </p>
<p>对于 $i=k$，$\sigma_k$ 为 $\tau -x$ 层的$2^x$ 个所有节点值：</p>
<p>$$\sigma_k = (N_{0,\tau-x},N_{1,\tau-x},,\dotsm, N_{2^x-1,\tau-x})$$</p>
<p>图示：</p>
<img src="sign.svg">


<h2 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验 (VER)"></a>消息校验 (VER)</h2><p>$$pk^\prime \leftarrow (M, \sigma, \mathcal{Q})$$</p>
<p>根据上述处理，得到<br>$$M = (M_0, M_1, \dotsm, M_{k-1})$$</p>
<p>对于 $i \in [0, k-1], y_i = \lfloor \frac{M_i}{2^\tau}-x\rfloor$，通过 $L_{M_i} = \mathcal{F}(\sigma^1_i)$ 和 $Auth_{M_i} = \sigma^2_i$ 计算出 $N^\prime_{y_i, \tau-x}$，和 $\sigma_k$ 中对应的进行比较，如果全部匹配，则返回根节点 $pk$，否则返回 $fail$。</p>
<p>其中 $\sigma_i^1$ 表示签名第 $i$ 个 $block$ 的第一部分内容，也就是私钥内容，$\sigma_i^1$ 表示签名第 $i$ 个 $block$ 的认证路径。</p>
<p>图示：</p>
<img src="verify.svg">]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
        <tag>FTS</tag>
      </tags>
  </entry>
  <entry>
    <title>签名算法</title>
    <url>/2021/12/24/cryptography/signature/signature/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>任意的签名算法都可以用一个三元组表示: ($GEN, SIG, VER$)，可以说是组成签名系统的三个算法。</p>
<ul>
<li>$GEN$: 密钥生成算法</li>
<li>$SIG$: 消息签名算法</li>
<li>$VER$: 消息校验算法</li>
</ul>
<p>定义一个接口表示： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Signature <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GenerateKey generates secret key and public key</span></span><br><span class="line">	GenerateKey() (sk []<span class="type">byte</span>, pk []<span class="type">byte</span>)</span><br><span class="line">	<span class="comment">// Sign computes signature of message using secret key</span></span><br><span class="line">	Sign(message []<span class="type">byte</span>, sk []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line">	<span class="comment">// Verify check if the signature is valid</span></span><br><span class="line">	Verify(message []<span class="type">byte</span>, pk []<span class="type">byte</span>, signature []<span class="type">byte</span>) <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细说说这三个算法。</p>
<span id="more"></span>

<h2 id="密钥生成算法"><a href="#密钥生成算法" class="headerlink" title="密钥生成算法"></a>密钥生成算法</h2><p>形式化表示为：</p>
<p>$$(pk, sk) \leftarrow GEN(1^k)$$</p>
<p>其中，$k$ 是安全参数，wiki 上给出了详细的说明：</p>
<blockquote>
<p>In cryptography, the security parameter is a variable that measures the input size of the computational problem. Both the resource requirements of the cryptographic algorithm or protocol as well as the adversary’s probability of breaking security are expressed in terms of the security parameter.</p>
</blockquote>
<p>也就是相当于说，安全性参数可以表示出破坏该签名安全性的概率和需要的资源等。</p>
<p>不过在实际中，我们可能会固定 $k$，比如为 256 等等。</p>
<p>指定安全参数之后，调用该方法，系统可以生成一对密钥，其中包括一个私钥和公钥，公钥可以公布，但是私钥必须安全保存。</p>
<h2 id="消息签名算法"><a href="#消息签名算法" class="headerlink" title="消息签名算法"></a>消息签名算法</h2><p>形式化表示为：<br>$$ \sigma(M) \leftarrow SIG(M, sk)$$</p>
<p>输入需要签名的消息，以及生成的私钥，该算法可以输出消息的签名。</p>
<h2 id="消息校验算法"><a href="#消息校验算法" class="headerlink" title="消息校验算法"></a>消息校验算法</h2><p>形式化表示为：<br>$$ false/true \leftarrow VER(M, \sigma(M), pk) $$</p>
<p>输出消息，和对应需要校验的签名，然后输入公钥，该算法可以确定消息是否完整，并可以校验发布者的身份，因为只用该发布者私钥签名的数据，才能成功通过该公钥解密。</p>
<h2 id="满足"><a href="#满足" class="headerlink" title="满足"></a>满足</h2><p>一个签名算法必须满足两个性质：</p>
<ol>
<li><strong>不可伪造性</strong>：其他用户不可能伪造签发者对数据进行签名。</li>
<li><strong>正确性</strong>：通过上述三个步骤进行计算，输出结果一定为 $true$。</li>
</ol>
<h2 id="Hash-based-签名方案分类"><a href="#Hash-based-签名方案分类" class="headerlink" title="Hash-based 签名方案分类"></a>Hash-based 签名方案分类</h2><h3 id="One-Time-Signature-OTS"><a href="#One-Time-Signature-OTS" class="headerlink" title="One Time Signature (OTS)"></a>One Time Signature (OTS)</h3><p>$OTS$ 的每一个密钥对，只能用来签名一条消息，因为在签名完第一次消息之后，该密钥对不再安全，攻击方可以 <strong>100%</strong> 伪造签名。</p>
<p>比如：<a href="">Lamport OTS</a>, <a href="">WOTS</a>.</p>
<h3 id="Few-Times-Signature-FTS"><a href="#Few-Times-Signature-FTS" class="headerlink" title="Few Times Signature (FTS)"></a>Few Times Signature (FTS)</h3><p>$FTS$ 的每一个密钥对，可以用来签名多个消息，但是随着签名的次数增加，安全性会急剧下降。</p>
<p>比如：<a href="">HORS</a>.</p>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
      </tags>
  </entry>
  <entry>
    <title>Merkle Tree &amp; Merkle Signature Scheme</title>
    <url>/2021/12/26/cryptography/signature/merkle/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Merkle Tree</strong> 又称 <strong>Hash Tree</strong>，实现一般为二叉树，当然也可以用多叉树实现，本质是一样的，WiKi 上也有相关介绍，点击<a href="https://en.wikipedia.org/wiki/Merkle_tree">这里</a>传送。</p>
<p>树的叶子节点处存放数据的哈希值，其他的非叶子节点通过子节点进行构造，按照下方公式：</p>
<p>$$node_i = hash(node_{2i+1} || node_{2i+2})$$</p>
<p>其中，节点 $i$ 是节点 $2i+1$ 和 $2i+2$ 的父结点，$||$ 表示串接，或者简单的说拼接，比如 $a = 0001_2, b = 1100_2$ 则<br>$$ c = a || b = 00011100_2$$</p>
<span id="more"></span>

<p>Merkle Tree 的结构如下：</p>
<img src="tree.svg">

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Merkle Tree 主要有以下两个作用。</p>
<p><strong>1. 校验数据的完整性</strong></p>
<p>现在比如说有一个文件很大，并没有存放在单独的一台机器上，而是分布在各个网络主机上，如果我们想要获取到该完整的文件，必须从各个主机上获取，然后进行合并，但是我们如何保证获取的文件是完整的，没有丢失任何数据？</p>
<p>我们可以提供数据的摘要来确保。每一份文件块均含有一个摘要，我们获取到该文件块的时候重新计算摘要，并且与之进行匹配，如果摘要不相等，说明文件块不对，需要重新传输。</p>
<blockquote>
<p>PS: 如果不需要防止主动攻击，比如消息篡改，使用 CRCs 等校验和算法即可。</p>
</blockquote>
<p>但是这样，我们需要从可信方获取获取所有的摘要值，代价有点高。</p>
<p>更好的方式是采用 Merkle Tree，我们首先会从可信方获取到文件的根哈希值 $root$，在每一个主机发送的内容中会提供当前数据的摘要，以及在 Merkle Tree 中的 Authentication path (下文会提到)，下载完数据之后，会根据 Authentication path 计算根哈希值 $root^\prime$，如果和 $root$ 不匹配，说明该文件下载错误，进行错误处理，重试或者放弃下载，如果匹配，则会继续下载。</p>
<p><strong>2. 减少签名中公钥的大小</strong></p>
<p>在没有使用 Merkle Tree 之前，比如我们需要保存 $2^h \times n$ bits 的公钥，可以认为是树中的所有叶子节点，但是使用 Merkle Tree，公钥变成了树的根节点，也就是只需要保存 $n$ bits，在 $h$ 达到一定大小的时候，节约的空间大小十分可观。</p>
<h2 id="Authentication-path"><a href="#Authentication-path" class="headerlink" title="Authentication path"></a>Authentication path</h2><p>Merkle Tree 中存在一个比较重要的概念：<strong>Authentication path</strong>，指的是，叶子节点到根节点经过的路径上的节点的兄弟节点集合。举个栗子，下面节点 $10$ 到根节点经过的节点有 $[10, 4, 1, 0]$，分别对应的兄弟节点为 $[9, 3, 2]$，即为节点 $10$ 的认证路径。</p>
<img src="auth.svg">

<p>通过已知节点和 Authentication path，我们可以计算出根节点的值，比如上面的这个例子中，执行下面的步骤，即可求出根节点：</p>
<ul>
<li>由 $10$ 和 $9$ 计算出 $4$ 的值</li>
<li>由 $4$ 和 $3$ 计算出 $1$ 的值</li>
<li>由 $1$ 和 $2$ 计算出根节点 $0$ 的值</li>
</ul>
<h2 id="Merkle-Signature-Scheme"><a href="#Merkle-Signature-Scheme" class="headerlink" title="Merkle Signature Scheme"></a>Merkle Signature Scheme</h2><p>Merkle Signature Scheme 由 <strong>Ralph Merkle</strong> 于 1979 年提出，简称 <strong>MSS</strong>，并不是一种单独的一种签名算法，而是整合了 <strong>Merkle Tree</strong> 和 <strong>OTS</strong> 形成的，论文见 <a href="a-certified-digital-signature.pdf">A Certified Digital Signature</a>。</p>
<p>下面按照三元组 $(GEN, SIG, VER)$ 对 MSS 签名系统进行介绍。</p>
<h3 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成($GEN$)"></a>密钥生成($GEN$)</h3><p>$$(pk, sk) \leftarrow GEN(1^k)$$</p>
<p>首先，我们需要确定树的高度 $h$，然后生成 $2^h$ 个 OTS 密钥对 $(X_j,Y_j)$，$j \in [0, 2^h-1]$。</p>
<p>依次计算值 $v_j = hash(Y_j)$，作为 Merkle Tree 的叶子节点，并且不断利用下方公式直至计算出根节点 (root) 的值，即为公钥 pk。</p>
<p>$$node_i = hash(node_{2i+1} || node_{2i+2})$$</p>
<p>私钥为 $2^h$ 个 OTS 私钥 $X_j$。</p>
<p>图示：</p>
<img src="gen.svg">

<h3 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名($SIG$)"></a>消息签名($SIG$)</h3><p>$$ \sigma(M) \leftarrow SIG(M, sk)$$</p>
<p>对于输入的消息 $M \in \{0,1\}^*$，首先挑选出一个 OTS 密钥对，索引为 $i, i \in [0, 2^h-1]$ ，该密钥对之前未被使用，一般按序选择，从左到右，然后使用该 OTS 私钥 $X_i$ 对消息进行签名，得到 $\sigma_{OTS}$，并且求出对应的公钥 $Y_i$ 的 Authentication path，记为 $auth_i$。</p>
<p>则签名为 </p>
<p>$$\sigma = (i, \sigma_{OTS}, Y_i, auth_i)$$</p>
<p>图示：</p>
<img src="sign.svg">

<h3 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验($VER$)"></a>消息校验($VER$)</h3><p>$$ false/true \leftarrow VER(M, \sigma(M), pk) $$</p>
<p>第一步，签名中包含 OTS 的公钥 $Y_i$，使用<br>$$false/true \leftarrow VER(M, \sigma_{OTS}, Y_i) $$</p>
<p>检验 $\sigma_{OTS}$，如果不通过，返回 $false$，停止计算，否则进行下一步。</p>
<p>第二步，根据 $i$ 和 $Y_i$，计算出 Merkle Tree 的根节点 $root^\prime$，与 $pk$ 进行比较，如果相等，校验通过，返回 $true$，否则返回 $false$。</p>
<p>图示：</p>
<img src="verify.svg">]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
      </tags>
  </entry>
  <entry>
    <title>Winternitz One Time Signature</title>
    <url>/2021/12/24/cryptography/signature/wots/</url>
    <content><![CDATA[<p>1979 年 <strong>Ralph C. Merkle</strong> 提出了 <strong>Winternitz-OTS</strong>，其中运用了哈希链(hash chain)的结构，论文见 <a href="a-certified-digital-signature.pdf" target="_blank">A Certified Digital Signature </a>，更加详细的算法描述见 <a href="hash-based-digital-signature-schemes.pdf" target="_blank">Hash-based Digital Signature Schemes</a>，该算法产生的一对密钥也只能签名一条消息。</p>
<p>下面按照 $(GEN, SIG, VER)$ 三元组描述该算法。</p>
<h2 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成($GEN$)"></a>密钥生成($GEN$)</h2><p>$$(pk, sk) \leftarrow GEN(1^k)$$</p>
<p>首先，我们需要确定 $w$ 参数该参数决定哈希私钥多少次构造公钥，此外还需确定哈希之后摘要的长度 $n$ ，或者可以认为是采用的哈希函数族。</p>
<span id="more"></span>

<p>一般情况下，我们要求：$w|n , w | 8$ ， 这将极大的简化之后的代码编写。</p>
<p>计算：</p>
<p>$$ l_1 = \lceil \frac{n}{w}\rceil,\ l_2 = \lfloor \frac{\log(l_1(2^w-1))}{w} \rfloor + 1 ,\ l = l_1 + l_2 $$</p>
<div style="font-size:12px;margin-bottom:10px;text-align:center">注: 这里采用 <a href="https://link.springer.com/chapter/10.1007/978-3-662-46800-5_15" target="_blank">SPHINCS</a> 中的计算公式，结果一致</div>

<p>通过 $PRG$ 生成 $l$ 个 $n$ bits 的随机数，即为私钥：</p>
<p>$$sk = (sk_0, sk_1, \dotsm, sk_{l-1})$$</p>
<p>对 $l$ 个随机数哈希 $2^w-1$ 次</p>
<p>$$pk_i = hash^{2^w-1}(sk_i)$$</p>
<p>组合即为公钥：</p>
<p>$$pk = (pk_0, pk_1, \dotsm, pk_{l-1})$$</p>
<p>图示：<br><img src="gen.svg"></p>
<h2 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名($SIG$)"></a>消息签名($SIG$)</h2><p>$$ \sigma(M) \leftarrow SIG(M, sk)$$</p>
<p>计算消息 $M \in \{0, 1\}^*$ 的摘要 $m \in \{0,1\}^n$，这 $n$ bits 进行填充，使其能够被 $w$ 整除，分成 $l_1$ 份，每一份 $w$ bits。</p>
<p>因为上面我们提到，要求 $w\mid n$，所以我们也可以认为，每一份 $w$ bits, 共 $l_1 = \frac{n}{w}$ 份。</p>
<p>$$m = (m_0,m_1,\dotsm,m_{l_1-1})$$</p>
<p>上述的每 $w$ bits 表示的 $m_i, i \in [0, l_1-1]$ 都可以表示一个整数，比如说 $w$ 为 4，$m_0$ 为 $1001_2$，则其表示 $9_{10}$</p>
<p>接下来计算校验和(Checksum)</p>
<p>$$C = \sum^{l_1}_{i=1}(2^w-1-m_i) \le l_1(2^w-1)$$</p>
<p>将 $C$ 同样表示每部分 $w$ bits，或者说转换成以 $w$ 为基的数字。</p>
<p>$$c = (c_0, c_1, \dotsm, c_{l_2-1})$$</p>
<p>设<br>$$b = (b_0, b_1, \dotsm, b_{l-1}) = m || c$$</p>
<p>即 $b$ 为 $m$ 和 $c$ 的串接。</p>
<p>则签名 </p>
<p>$$\begin{aligned}<br>  \sigma &amp;= (\sigma_0, \sigma_1, \dotsm, \sigma_{l-1}) \\<br>&amp;= (hash^{b_0}(sk_0), hash^{b_1}(sk_1), \dotsm, hash^{b_{l-1}}(sk_{l-1}))<br>\end{aligned}$$</p>
<p>图示：<br><img src="sign.svg"></p>
<h2 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验($VER$)"></a>消息校验($VER$)</h2><p>$$ false/true \leftarrow VER(M, \sigma(M), pk) $$</p>
<p>通过上述同样的方式将消息 $M$ 转换成 </p>
<p>$$b = (b_0, b_1, \dotsm, b_{l-1})$$</p>
<p>将传递过来的签名<br>$$\sigma = (\sigma_0, \sigma_1, \dotsm, \sigma_{l-1})$$</p>
<p>进行如下处理，得到 $pk^\prime$</p>
<p>$$\begin{aligned}<br>  pk^\prime &amp;= (pk^\prime_0, pk^\prime_1, \dotsm, pk ^\prime_{l-1}) \\<br>  &amp;= (hash^{2^w-1-b_0}(\sigma_0), hash^{2^w-1-b_1}(\sigma_1), \dotsm,hash^{2^w-1-b_{l-1}}(\sigma_{l-1}))<br>\end{aligned}$$</p>
<p>和公钥 </p>
<p>$$pk = (pk_0, pk_1, \dotsm, pk_{l-1})$$</p>
<p>进行匹配，如果 $pk = pk^\prime$ 则校验通过，返回 $true$，否则返回 $false$</p>
<p>图示：<br><img src="verify.svg"></p>
]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
        <tag>OTS</tag>
      </tags>
  </entry>
  <entry>
    <title>SPHINCS</title>
    <url>/2022/01/15/cryptography/signature/sphincs/</url>
    <content><![CDATA[<p>SPHINCS 于 2015 年由 <strong>Bernstein, Daniel J., Daira Hopwood, Andreas Hülsing</strong> 等人提出，具体的论文见 <a href="/2021/12/27/cryptography/signature/horst/sphincs.pdf" target="_blank">SPHINCS: practical stateless hash-based signatures</a>。</p>
<p>SPHINCS 是一个无状态的签名系统。有状态指的是每次签名时需要记录系统的信息，比如是第几次签名，在验证的时候需要使用该参数，而无状态的签名系统则不需要保存这些信息。相对于有状态的签名系统，无状态的签名系统不需要记录签名的状态，符合标准的 API 且方便在不同主机上移植，无状态的签名系统是更好的选择。</p>
<p>SPNHICS 基于多种签名算法，比如 <a href="/2021/12/28/cryptography/signature/wots-plus/" target="_blank">WOTS+</a>, <a href="/2021/12/27/cryptography/signature/horst/" target="_blank">HORST</a> 等，如果不了解相关内容，建议先参考之前的文章。</p>
<span id="more"></span>

<p>SPHINCS 的结构大致如下：</p>
<img src="sphincs_structure.png" style="height: 400px; text-align: center">

<p>每一个层的 Tree 都是一个 <strong>binary hash tree</strong>，叶子节点是 <strong>WOTS+</strong> 公钥通过 <strong>L-Tree</strong> 形成的根节点，这里的密钥对用来认证，最下面的 <strong>HORST</strong> 用来签名消息。</p>
<p>SPHINCS 中使用 <strong>address scheme</strong> 来进行伪随机密钥的生成，一个地址(address) 由三个部分组成：</p>
<img src="address.svg">


<p>其中，Tree 部分的层数，从上到下，依次是 $d-1,d-2, \dotsm, 0$，HORST 属于 $d$ 层。</p>
<p>下面通过 $(GEN, SIG, VER)$ 三部分进行讲解。</p>
<h2 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成 (GEN)"></a>密钥生成 (GEN)</h2><p>$$(SK, PK) \leftarrow GEN(1^k)$$</p>
<p>首先，在 SPHINCS 中存在下面的几个参数:</p>
<table>
<thead>
<tr>
<th>paramter</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>$n$</td>
<td>biglength of hashes in HORST and WOTS</td>
</tr>
<tr>
<td>$m$</td>
<td>bitlength of the message hash</td>
</tr>
<tr>
<td>$h$</td>
<td>height of the hyper-tree</td>
</tr>
<tr>
<td>$d$</td>
<td>layers of the hyper-tree</td>
</tr>
<tr>
<td>$w$</td>
<td>Winternitz parameter used for WOTS signatures</td>
</tr>
<tr>
<td>$t$</td>
<td>number of secret-key elements of HORST</td>
</tr>
<tr>
<td>$k$</td>
<td>number of revealed secret-key elements per HORST sig.</td>
</tr>
</tbody></table>
<p>在 $SPHINCS-256$ 中，分别为</p>
<p>$$n=256, m = 512, h=60,d=12,w=16,t=2^{16},k=32$$</p>
<p>由 PRG 生成两个随机数作为私钥：</p>
<p>$$(SK_1, SK_2) \in \{0, 1\} ^ n \times \{0,1\}^n$$</p>
<p>$SK_1$ 用来生成密钥，$SK_2$ 在签名的时候用来生成不可预测的 $index$ 和随机化消息的哈希值。</p>
<p>然后生成 $p$ 个随机数作为掩码</p>
<p>$$Q = (Q_0, Q_1, \dotsm, Q_{p-1}) \leftarrow \{0, 1\} ^{p\times n}$$ </p>
<p>且 $p$ 满足</p>
<p>$$ p = \max\{2^w-1, 2(h+\lceil \log l \rceil), 2 \log t\}$$</p>
<p>并且设</p>
<p>$$\begin{aligned}<br>   Q_{WOTS+} &amp;= (Q_0, Q_1, \dotsm, Q_{2^w-2})<br>  \\<br>   Q_{HORST} &amp;= (Q_0, Q_1, \dotsm, Q_{2\log t-1})<br>  \\<br>   Q_{L-Tree} &amp;= (Q_0, Q_1, \dotsm, Q_{2\lceil \log l \rceil-1})<br>  \\<br>   Q_{Tree} &amp;= (Q_{2\lceil \log l \rceil},Q_{2\lceil \log l \rceil+1}, \dotsm, Q_{2(h+\lceil \log l \rceil)-1} )<br>\end{aligned} $$</p>
<p>即 $Q_{WOTS+}$ 为 $Q$ 的前 $2^w-1$ 个， $Q_{HORST}$ 为 $Q$ 的前 $2 \log t$ 个，$Q_{L-Tree}$ 为前 $2\lceil \log l \rceil$ 个，$Q_{Tree}$ 为 $Q_{L-Tree}$ 随后的 $2h$ 个。</p>
<p>最后，我们需要生成最上层的 Tree，也就是 layer d-1 的树。叶子节点为 WOTS+ 密钥对，通过上述的 <strong>address scheme</strong> 计算叶子节点的地址：</p>
<p>$$A = (d-1||0||i),  i \in [0, 2^{h/d}-1]$$</p>
<p>随后可以计算出对应的随机数种子：</p>
<p>$$S_A \leftarrow \mathcal{F_a}(A, SK_1)$$</p>
<p>此处，将 $\mathcal{F_a}$ 认为是一个哈希函数即可。</p>
<p>然后我们就可以生成对应的公钥了</p>
<p>$$pk_A \leftarrow WOTS.kg(S_A, Q_{WOTS+})$$</p>
<p>生成的 $$pk_A$$ 由 $l$ 个 $blocks$ 构成，将其构造成一个 <strong>L-Tree</strong>，根节点就是在 Tree 上的叶子节点值。</p>
<p>就这样，我们可以获取到 $Tree_0$ 的根节点值 $PK_1$。</p>
<p>从而，SPHINCS 的公私钥为：</p>
<p>$$<br>\begin{cases}<br>  SK = (SK_1, SK_2, Q)<br>  \\<br>  PK = (PK_1, Q)<br>\end{cases}<br>$$</p>
<p>图示：</p>
<img src="gen.svg">

<h2 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名 (SIG)"></a>消息签名 (SIG)</h2><p>$$\Sigma \leftarrow sign(M,SK)$$</p>
<p>对于输入的 $M\in \{0, 1\}^*, SK = (SK_1, SK_2,Q )$ ，首先计算消息的随机摘要，利用 $M,SK_2$ 生成一个随机数</p>
<p>$$R = (R_1, R_2) \in \{0, 1\}^n \times \{0,1\}^n \leftarrow \mathcal{F}(M, SK_2)$$</p>
<p>取 $R_1$ 计算消息的随机摘要：</p>
<p>$$D \leftarrow \mathcal{H}(R_1, M)$$</p>
<p>取 $R_2$ 的前 $h$ bits 选择 HORST 密钥对</p>
<p>$$i \leftarrow C_{HOP}(R_2,h)$$</p>
<p>因为树高 $h$，$h$ bits 包含 $2^h$ 个数，正是 HORST 的数量。</p>
<p>已知 $i$ 之后，我们可以计算该 HORST 的地址</p>
<p>$$A_{HORST} = (d || i(0, (d-1)h/d)||i((d-1)h/d,h/d))$$</p>
<p>其中， $i(start, length)$ 表示从 $start$ 比特位开始，截取 $length$ 长度的比特值。</p>
<p>同理，计算出对应的随机数种子：</p>
<p>$$S_{HORST} \leftarrow \mathcal{F_a}(A_{HORST}, SK_1)$$</p>
<p>根据随机数种子和掩码 $Q$，我们可以获取到：</p>
<p>$$(\sigma_H, pk_H) \leftarrow HORST.sign(D, S_{A_{HORST}}, Q_{HORST})$$</p>
<p>对于 layer $j, j \in [0, d)$，计算 WOTS+ 密钥对的地址：</p>
<p>$$A_j = (j || i(0, (d-1-j)h/d) || i((d-1-j)h/d,h/d))$$</p>
<p>计算出地址之后，求出对应的随机数种子</p>
<p>$$S_{A_j} = \mathcal{F_a}(A_j, SK_1)$$</p>
<p>然后计算签名：</p>
<p>$$\sigma_{w,j} \leftarrow WOTS.sign(pk_{w,j-1}, S_{A_j}, Q_{WOTS+})$$</p>
<p>$pk_{w,j-1}$ 就是 Tree 的根节点，这里取 $\sigma_{-1} = pk_H$，也就是 HORST 的根节点，同时，我们还需要求出 WOTS+ 密钥对的认证路径 $Auth_{A_{d-1}}$。</p>
<p>最后得出，签名为：</p>
<p>$$\Sigma = (i, R_1, \sigma_H, \sigma_{W, 0}, Auth_{A_0}, \dotsm, \sigma_{W,d-1}, Auth_{A_{d-1}})$$</p>
<p>图示：</p>
<img src="sign.svg">


<h2 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验 (VER)"></a>消息校验 (VER)</h2><p>$$b\leftarrow VEF(M,\Sigma, PK)$$</p>
<p>对于消息 $M\in \{0,1\}^*$ 计算出摘要 $D \leftarrow \mathcal{H}(R_1, M)$。</p>
<p>然后首先校验 $\sigma_H$：</p>
<p>$$pk_H \leftarrow HORST.verify(D, \sigma_H, Q_{HORST})$$</p>
<p>如果校验没通过，返回失败，否则进行下一步。</p>
<p>计算 WOTS+ 的公钥</p>
<p>$$pk_{W,0} \leftarrow WOTS.verify(pk_H, \sigma_{w,0}, Q_{HORST})$$</p>
<p>公钥共 $l\ blocks$，形成 L-Tree，计算出根节点，结合 $Auth_{A_0}$ 计算出 Tree 的根节点。</p>
<p>对于 layer 1~d-1，也是类似的操作，最后得出最上面的那棵树的根节点 $ROOT_{d-1}$，如果 $PK_1 = ROOT_{d-1}$，那么返回 true，否则返回 false。</p>
<p>图示：</p>
<img src="verify.svg">

]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
        <tag>stateless</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 编写 derive 宏</title>
    <url>/2022/09/03/rust/macro/derive/</url>
    <content><![CDATA[<p>宏可以帮助我们减少重复代码的编写，在 Rust 中有两种宏定义，</p>
<ul>
<li>声明宏</li>
<li>过程宏</li>
</ul>
<p>其中，声明宏只是简单的 <code>token</code> 替换，我们无法知道代码结构中的其他信息，过程宏可以获取更加详细的数据，比如我们可以获取结构体中字段的名称，类型等等。</p>
<span id="more"></span>
<img src="rust-complie-process.png">

<p>下面介绍如何编写一个简单的 derive 过程宏。</p>
<p>首先对于过程宏来说，不能和引用的 <code>crate</code> 放置在同一个 <code>crate</code> 中，需要单独放置在一个 <code>crate</code> 中，同时我们需要在 <code>Cargo.toml</code> 中配置</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<p>对于 <code>derive</code> 宏而言，即为输入为 <code>TokenStream</code>，输出也是 <code>TokenStream</code> 的函数，且输出的内容会 <code>append</code> 到代码中，而不会覆盖输入的内容</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">proc_marco</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>syn</code> 对输入进行解析，获取其中的 <code>token</code> 信息，使用 <code>quote</code> 构造输出</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>proc_macro_derive</code> 来标注这个函数是一个 <code>derive</code> 宏，同时也可以指定 <code>attributes</code> 用于指定可以在宏范围中使用的 <code>attr</code>，可以指定多个使用逗号进行分割。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(PrintField, attributes(field, typ))]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_field</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream;</span><br></pre></td></tr></table></figure>
<p>如果要使用该宏，使用方式如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(PrintField)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">  <span class="meta">#[field=<span class="string">&quot;hi&quot;</span>]</span></span><br><span class="line">  host: <span class="type">String</span>, </span><br><span class="line">  port: <span class="type">u16</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>derive</code> 宏的具体编写步骤主要分成以下三步</p>
<ol>
<li>使用 <code>syn</code> 提供的方法解析输入</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(PrintField, attributes(field, typ))]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_field</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">DeriveInput</span> &#123; ident, data, .. &#125; = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从输入中获取到需要的信息，进行保存</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(PrintField, attributes(field, typ))]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_field</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">DeriveInput</span> &#123; ident, data, .. &#125; = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">field_names</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">syn</span>::Data::<span class="title function_ invoke__">Struct</span>(s) = data &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">syn</span>::Fields::<span class="title function_ invoke__">Named</span>(f) = s.fields &#123;</span><br><span class="line">            <span class="comment">// 获取所有的字段名字，最后进行打印</span></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">field</span> <span class="keyword">in</span> f.named.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">                field_names.<span class="title function_ invoke__">push</span>(</span><br><span class="line">                    field</span><br><span class="line">                        .ident</span><br><span class="line">                        .<span class="title function_ invoke__">as_ref</span>()</span><br><span class="line">                        .<span class="title function_ invoke__">map</span>(|ident| ident.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">                        .<span class="title function_ invoke__">unwrap_or_default</span>(),</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, field_names);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 <code>quote</code> 构造输出</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(PrintField, attributes(field, typ))]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print_field</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">DeriveInput</span> &#123; ident, data, .. &#125; = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">field_names</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">syn</span>::Data::<span class="title function_ invoke__">Struct</span>(s) = data &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">syn</span>::Fields::<span class="title function_ invoke__">Named</span>(f) = s.fields &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, f.<span class="title function_ invoke__">to_token_stream</span>().<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">field</span> <span class="keyword">in</span> f.named.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">                field_names.<span class="title function_ invoke__">push</span>(</span><br><span class="line">                    field</span><br><span class="line">                        .ident</span><br><span class="line">                        .<span class="title function_ invoke__">as_ref</span>()</span><br><span class="line">                        .<span class="title function_ invoke__">map</span>(|ident| ident.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">                        .<span class="title function_ invoke__">unwrap_or_default</span>(),</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, field_names);</span><br><span class="line">    quote!(</span><br><span class="line">      <span class="keyword">impl</span> #ident &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_world</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ).<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数中的 <code>Ident</code> 类型变量，使用 <code>#variable_name</code> 的方式在 <code>quote</code> 中进行引用，不能直接使用字符串，可以通过下面的方式进行创建</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro2::Span;</span><br><span class="line"><span class="keyword">use</span> syn::Ident;</span><br><span class="line">Ident::<span class="title function_ invoke__">new</span>(<span class="string">&quot;fn_name&quot;</span>, Span::<span class="title function_ invoke__">call_site</span>()); </span><br></pre></td></tr></table></figure>

<p>如果需要进行循环迭代，可以使用 <code>#()*</code> 的方式表示</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn_name 可以理解为 Vec&lt;Ident&gt; 类型</span></span><br><span class="line"><span class="keyword">impl</span> #ident &#123;</span><br><span class="line">   #(</span><br><span class="line">      <span class="keyword">pub</span> <span class="keyword">fn</span> #<span class="title function_ invoke__">fn_name</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;call &#123;&#125;&quot;</span>, #fn_name.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">      &#125;</span><br><span class="line">     ) *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为宏是在编译的过程中进行处理的，所以即使我们宏中代码实现的不高效，不影响运行时性能。编写好的宏，可以使用 <code>cargo expand</code> 命令进行展开，如果提示没找到该命令，使用 <code>cargo install cargo-expand</code> 进行安装。</p>
<p>简单写了一个 <code>derive</code> 宏自动为结构体生成 <code>setter</code> 和 <code>getter</code> 方法，仓库：<a href="https://github.com/junhaideng/construct">construct</a>，可以学习参考。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Note</category>
        <category>Macro</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>WOTS+</title>
    <url>/2021/12/28/cryptography/signature/wots-plus/</url>
    <content><![CDATA[<p>本文建立在 WOTS 签名系统基础上，若还尚不熟悉该签名系统，可参考另一篇文章 <a href="/2021/12/24/cryptography/signature/wots" target="_blank">Winternitz One Time Signature</a>，论文见 <a href="wots-plus.pdf" target="_blank">W-OTS+ – Shorter Signatures for Hash-Based Signature Schemes</a>，该算法产生的一对密钥只能签名一条消息。</p>
<p>下面按照 $(GEN, SIG, VER)$ 三元组描述该算法。</p>
<h2 id="密钥生成-GEN"><a href="#密钥生成-GEN" class="headerlink" title="密钥生成($GEN$)"></a>密钥生成($GEN$)</h2><p>$$(pk, sk) \leftarrow GEN(1^k)$$</p>
<p>首先，我们需要确定 $w$ 参数该参数决定哈希私钥多少次构造公钥，此外还需确定哈希之后摘要的长度 $m$ ，或者可以认为是采用的哈希函数族，$n$ 为其他哈希值长度。</p>
<span id="more"></span>

<p>一般情况下，我们要求：$w|m , w | 8$ ， 这将极大的简化之后的代码编写。</p>
<p>计算：</p>
<p>$$ l_1 = \lceil \frac{m}{w}\rceil,\ l_2 = \lfloor \frac{\log(l_1(2^w-1))}{w} \rfloor + 1 ,\ l = l_1 + l_2 $$</p>
<p>定义 $c^i(x, \boldsymbol{r})$ 运算：</p>
<p>$$<br>c^i(x,\boldsymbol{r}) =<br>\begin{cases}<br>  &amp; x, &amp; i = 0 \\<br>  &amp; \mathcal{F}(c^{i-1}(x,\boldsymbol{r})\oplus r_i), &amp; i \gt 0<br>\end{cases}<br>$$</p>
<p>其中<br>$$\begin{aligned}<br>&amp; x \in \{0,1\}^n<br>\\<br> &amp; \mathcal{F}: \{0,1\}^n \rightarrow \{0,1\}^n<br>\\<br> &amp; \boldsymbol{r} = (r_1, r_2, \dotsm, r_{2^w-1}) \in \{0,1\}^{n\times (2^w-1)}<br>\end{aligned}<br>$$</p>
<p>定义 </p>
<p>$$\boldsymbol{r}_{a,b} =<br>\begin{cases}<br>  &amp;(r_a, r_{a+1}, \dotsm, r_b), &amp; a \ge b<br>  \\<br>  &amp; \emptyset , &amp; a &lt; b<br>\end{cases}$$</p>
<blockquote>
<p>注：原文中使用 $c^i_k(x,\boldsymbol{r})$ 含有参数 $k$，用来确定使用的哈希函数，这里为了简单和方便理解，不再暴露该参数。在实现中，通常我们会指定特定的哈希函数，不会使用参数 $k$。</p>
</blockquote>
<p>通过 $PRG$ 生成 $l+2^w-1$ 个 $n$ bits 的随机数，前 $l$ 个随机数即为私钥：</p>
<p>$$sk = (sk_0, sk_1, \dotsm, sk_{l-1})\tag{1}$$</p>
<p>后 $2^w-1$ 个为掩码</p>
<p>$$\boldsymbol{r} = (r_1, r_2, \dotsm, r_{2^w-1})$$</p>
<p>公钥包括 $l+1$ 个 $blocks$，第一个 $block$ 为掩码 $\boldsymbol{r}$。后 $l$ 个通过 $sk$ 进行转换：</p>
<p>$$pk_i = c^{2^w-1}(sk_{i-1},\boldsymbol{r}), i \in [1,l]$$</p>
<p>最终，公钥为</p>
<p>$$\begin{aligned}<br>  pk &amp;= (pk_0, pk_1, \dotsm, pk_l) \\<br>  &amp;= (\boldsymbol{r}, c^{2^w-1}(sk_0, \boldsymbol{r}), \dotsm, c^{2^w-1}(sk_{l-1}, \boldsymbol{r}))<br>\end{aligned}<br>\tag{2}<br>$$</p>
<p>图示：</p>
<img src="gen.svg">

<h2 id="消息签名-SIG"><a href="#消息签名-SIG" class="headerlink" title="消息签名($SIG$)"></a>消息签名($SIG$)</h2><p>$$ \sigma(M) \leftarrow SIG(M, sk)$$</p>
<p>使用哈希函数</p>
<p>$$\mathcal{H}: \{0, 1\}^* \rightarrow \{0,1 \}^m$$</p>
<p>计算消息 $M \in \{0, 1\}^*$ 的摘要 $m \in \{0,1\}^m$，这 $m$ bits 分成 $l_1$ 份，每一份 $w$ bits。</p>
<p>$$m = (m_0,m_1,\dotsm,m_{l_1-1})$$</p>
<p>上述的每 $w$ bits 表示的 $m_i, i \in [0, l_1-1]$ 等价于一个整数。</p>
<p>接下来计算校验和(Checksum)</p>
<p>$$C = \sum^{l_1}_{i=1}(2^w-1-m_i) \le l_1(2^w-1)$$</p>
<p>将 $C$ 同样表示每部分 $w$ bits，或者说转换成以 $w$ 为基的数字。</p>
<p>$$c = (c_0, c_1, \dotsm, c_{l_2-1})$$</p>
<p>设<br>$$b = (b_0, b_1, \dotsm, b_{l-1}) = m || c$$</p>
<p>即 $b$ 为 $m$ 和 $c$ 的串接。</p>
<p>则签名 </p>
<p>$$\begin{aligned}<br>  \sigma &amp;= (\sigma_0, \sigma_1, \dotsm, \sigma_{l-1}) \\<br>&amp;= (\mathcal{F}^{b_0}(sk_0, \boldsymbol{r}), \mathcal{F}^{b_1}(sk_1,\boldsymbol{r}), \dotsm, \mathcal{F}^{b_{l-1}}(sk_{l-1},\boldsymbol{r}))<br>\end{aligned}$$</p>
<p>图示：</p>
<img src="sign.svg">

<h2 id="消息校验-VER"><a href="#消息校验-VER" class="headerlink" title="消息校验($VER$)"></a>消息校验($VER$)</h2><p>$$ false/true \leftarrow VER(M, \sigma(M), pk) $$</p>
<p>通过上述同样的方式将消息 $M$ 转换成 </p>
<p>$$b = (b_0, b_1, \dotsm, b_{l-1})$$</p>
<p>将传递过来的签名<br>$$\sigma = (\sigma_0, \sigma_1, \dotsm, \sigma_{l-1})$$</p>
<p>进行如下处理，得到 $pk^\prime$</p>
<p>$$\begin{aligned}<br>  pk^\prime &amp;= (\boldsymbol{r}, pk^\prime_1, pk^\prime_2, \dotsm, pk ^\prime_{l}) \\<br>  &amp;= (\boldsymbol{r}, \mathcal{F}^{2^w-1-b_0}(\sigma_0), \mathcal{F}^{2^w-1-b_1}(\sigma_1), \dotsm,\mathcal{F}^{2^w-1-b_{l-1}}(\sigma_{l-1}))<br>\end{aligned}$$</p>
<p>和公钥 </p>
<p>$$pk = (\boldsymbol{r},pk_1, pk_2, \dotsm, pk_{l})$$</p>
<p>进行匹配，如果 $pk = pk^\prime$ 则校验通过，返回 $true$，否则返回 $false$。</p>
<p>图示：</p>
<img src="verify.svg">

]]></content>
      <categories>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
        <tag>signature</tag>
        <tag>hash-based</tag>
        <tag>OTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 报错 package xxx is not in GOROOT or GOPATH 或者 cannot find package “xxx“ in any of</title>
    <url>/2020/07/11/golang/fundamental/import-package/</url>
    <content><![CDATA[<h2 id="GO111MODULE-”off”"><a href="#GO111MODULE-”off”" class="headerlink" title="GO111MODULE=”off”"></a>GO111MODULE=”off”</h2><p>在 <code>GO111MODULE=&quot;off&quot;</code> 的条件下，并且写的代码不在 <code>$GOPATH/src</code> 下，也就是说下面的 <code>main.go</code> 不在<code>$GOPATH/src</code> 目录下面，同时我想要使用当前项目目录下的另一个 <code>module</code> 里面的可导出标识符(函数、变量等)，但是这个模块 <code>不是标准库</code>，或者说不在 GOROOT 里(一般我们不会修改 GOROOT 中的内容)</p>
<span id="more"></span>

<img src="structure.png">

<p>运行代码会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.go:4:2: cannot find package &quot;module&quot; in any of:</span><br><span class="line">        /usr/local/go/src/module (from $GOROOT)</span><br><span class="line">        /home/linux/go/src/module (from $GOPATH)</span><br></pre></td></tr></table></figure>

<h3 id="解决方案-设置-GOPATH"><a href="#解决方案-设置-GOPATH" class="headerlink" title="解决方案: 设置 GOPATH"></a>解决方案: 设置 <code>GOPATH</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPATH=~/test</span><br><span class="line"><span class="comment"># 这里设置为 ~/test是因为我需要在~/test/src下面写代码</span></span><br></pre></td></tr></table></figure>

<p>然后在 <code>$GOPATH/src</code> 目录下写</p>
<img src="1.png">

<p>go 的编译器会在 <code>$GOPATH/src</code> 下面寻找对应的模块，src 下的每一个目录都可以对应一个模块，目录中的目录也可以是一个模块，如果，我们需要访问一个嵌套目录中的模块，比如下图</p>
<img src="2.png" >

<p>我们需要调用 module 目录中的 moduleA 模块，只需要使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;module/moduleA&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><img src="gopath.gif">

<hr/>

<h2 id="GO111MODULE-”on”"><a href="#GO111MODULE-”on”" class="headerlink" title="GO111MODULE=”on”"></a>GO111MODULE=”on”</h2><p>在 <code>GO111MODULE=&quot;on&quot;</code> 的条件下，我们直接调用写好的模块，如下图所示</p>
<img src="3.png">

<p>会直接报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.go:4:2: package module is not in GOROOT (/usr/local/go/src/module)</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>第一种方式：设置 <code>GO111MODULE=&quot;off&quot;</code>，然后像上面的那种方式一样设置 <code>GOPATH</code></li>
<li>第二种方式：使用 <code>go mod</code>，如下</li>
</ul>
<img src="4.png">

<p>首先我们需要初始化一个 <code>go.mod</code> ，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init <span class="built_in">test</span></span><br><span class="line"><span class="comment"># test可以是任意的名称</span></span><br></pre></td></tr></table></figure>

<p>然后我们引入模块的时候，以 <code>test</code> (初始化时定义)开头，然后接模块路径，比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;test/module&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用这种方式 Goland 报错，但是可以进行正常编译，那么可以删除当前目录下的 <code>.idea</code> 目录然后重启项目即可</p>
</blockquote>
<p>如果我们想要引用嵌套模块也是一样的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;test/module/moduleA&quot;</span></span><br></pre></td></tr></table></figure>

<img src="5.png">

<h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><img src="gomod.gif">]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>package</tag>
        <tag>fundamental</tag>
      </tags>
  </entry>
  <entry>
    <title>cargo 中的语义版本控制系统</title>
    <url>/2022/01/04/rust/cargo/version/</url>
    <content><![CDATA[<p>Cargo 和其他很多工具一样，遵循<strong>语义版本控制系统</strong>，程序库以</p>
<p>$$\text{major.minor.patch}$$</p>
<p>格式指定，其中</p>
<ul>
<li><code>major</code>：项目进行重大更新，且包含不向后兼容的功能</li>
<li><code>minor</code>：仅在以向后兼容的方式添加新功能</li>
<li><code>patch</code>：仅在以向后兼容的方式修复错误，并且没有添加任何新的功能</li>
</ul>
<span id="more"></span>

<p>在 <code>Cargo.toml</code> 中，当我们指定了完整的版本号，如 <code>1.0.0</code>，那么 cargo 会帮我们拉取对应版本号的代码；</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># serde = &#123; version = &quot;1.0.0&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>当我们不关心补丁版本号时，如指定 <code>1.0</code>，那么 cargo 会帮我们拉取 <code>1.0.*</code> 的最高版本号对应的库，当我们只关心主版本号时，如指定版本号为 <code>1</code>，那么 cargo 会拉取主版本号为 1 对应的最新库。</p>
<p>虽然我们也可以直接指定最新的版本，如下，但是由于版本之间可能不兼容，所以<strong>强烈不推荐</strong>，并且 Crates.io 不允许上传具有通配符依赖关系的包。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>


<p>我们也可以指定最低的版本号：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;^1.1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的这种书写方式表示，使用最新的 <code>1.*.*</code> 的版本号，并且版本号至少为 <code>1.1.0</code>。</p>
<p>以下是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^1.2.3 := &gt;=1.2.3 &lt;2.0.0</span><br><span class="line">^1.2 := &gt;=1.2.0 &lt;2.0.0</span><br><span class="line">^1 := &gt;=1.0.0 &lt;2.0.0</span><br><span class="line">^0.2.3 := &gt;=0.2.3 &lt;0.3.0</span><br><span class="line">^0.2 := &gt;= 0.2.0 &lt; 0.3.0</span><br><span class="line">^0.0.3 := &gt;=0.0.3 &lt;0.0.4</span><br><span class="line">^0.0 := &gt;=0.0.0 &lt;0.1.0</span><br><span class="line">^0 := &gt;=0.0.0 &lt;1.0.0</span><br></pre></td></tr></table></figure>

<p>我们也可以指定更新最小版本，如果指定 major 版本，minor 版本和 patch 程序版本，或仅指定 major 版本和 minor 版本，则仅允许 patch 程序级别更改。如果仅指定 major 版本，则允许进行 minor 和 patch 级别更改。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;~1.1.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>意思是我们可以使用版本 <code>&gt;=1.1.0 &amp;&amp; &lt; 2.0.0</code> 的代码库。</p>
<p>一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~1.2.3 := &gt;=1.2.3 &lt;1.3.0</span><br><span class="line">~1.2 := &gt;=1.2.0 &lt;1.3.0</span><br><span class="line">~1 := &gt;=1.0.0 &lt;2.0.0</span><br></pre></td></tr></table></figure>

<p>因为我们也可能直接从 GitHub 等网站上拉取代码库，所以我们可以直接指定</p>
<p>此外，cargo 还有很多其他的工具链可以下载，比如 <code>cargo-edit</code> 提供了 4 条命令：cargo add、cargo rm、cargo edit、cargo upgrade，使用 <code>cargo install cargo-edit</code> 即可下载安装这 4 条命令。</p>
<p>cargo add 时，我们可以直接指定需要的版本号，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo add serde@1.0.0</span><br></pre></td></tr></table></figure>

<p>更多详细内容可见 <a href="https://rustwiki.org/zh-CN/cargo/reference/specifying-dependencies.html">指定依赖</a></p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Cargo</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相加</title>
    <url>/2021/06/26/golang/source-code/string-add/</url>
    <content><![CDATA[<p>本节内容主要代码位于 <code>runtime/string.go</code></p>
<p>以下面的代码进行说明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello &quot;</span></span><br><span class="line">b := <span class="string">&quot;World &quot;</span></span><br><span class="line">_ = a + b</span><br></pre></td></tr></table></figure>

<p>当执行 <code>a+b</code> 的时候，底层上调用的是 <code>concatstrings</code>，并且将a, b 两个操作数作为 <code>slice</code> 传递进去，如下：</p>
<span id="more"></span>

<img src="goland.png">

<p><code>tmpBuf</code> 是一个预定义的 <code>tmpStringBufSize</code> 大小的 <code>byte</code> 数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpStringBufSize = <span class="number">32</span></span><br><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="type">byte</span></span><br></pre></td></tr></table></figure>

<p>函数中首先定义了三个变量，<code>idx</code> 表示当前遍历的字符串索引号，<code>l</code> 表示当前拼接得到的字符串长度，<code>count</code> 表示长度不为0的字符串个数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">idx := <span class="number">0</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">count := <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后我们遍历每一个字符串，通过 <code>len</code> 函数获取到它的长度，如果长度为0，执行 <code>continue</code>，不需要进行其他操作，由于拼接之后的字符串长度可能过长，导致整数溢出，所以源码中使用 <code>l+n&lt;l</code> 加以判断，当溢出的时候抛出错误。执行这个遍历之后，我们获取到了最终的字符串长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(x)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> l+n &lt; l &#123;</span><br><span class="line">			throw(<span class="string">&quot;string concatenation too long&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		l += n</span><br><span class="line">		count++</span><br><span class="line">		idx = i</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>遍历完成之后，如果 <code>count</code> 为0，说明并没有实在意义的字符串，直接返回空字符串，如果 <code>count</code> 为1，那么我们直接返回对应的字符串就好，无需进行拼接，这个时候，<code>count</code> 为1，那么必然满足条件的这个字符串的索引号为 <code>idx</code>，所以直接返回 <code>a[idx]</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;</span><br><span class="line">	<span class="keyword">return</span> a[idx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这里除了需要判断 <code>count==1</code> 之外，我们还需要判断 <code>a[idx]</code> 是否还在栈上，或者 <code>buf</code> 是否从调用帧逃逸出去了，这样我们才能够直接返回。</p>
<p>这里的 <code>stringDataOnStack</code> 其实还挺好玩的，代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringDataOnStack</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	ptr := <span class="type">uintptr</span>(stringStructOf(&amp;s).str)</span><br><span class="line">	stk := getg().stack</span><br><span class="line">	<span class="keyword">return</span> stk.lo &lt;= ptr &amp;&amp; ptr &lt; stk.hi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道其实一个字符串就是一个 <code>stringStruct</code> 结构体，str 指向底层保存的数据，len 保存长度，在运行的每一个 <code>goroutine</code> 都分配了自己的栈空间，我们只需要判断这个地址是否在栈范围之内就好，也就是 <code>stk.lo &lt;= ptr &amp;&amp; ptr &lt; stk.hi</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	str unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的条件都不满足，那么我们需要进行下一步操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s, b := rawstringtmp(buf, l)</span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">    <span class="built_in">copy</span>(b, x)</span><br><span class="line">    b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 <code>rawstringtmp</code> 返回一个 <code>string</code> 类型的 <code>s</code> 和一个 <code>[]byte</code> 的 <code>b</code>，其中 <code>s</code> 的底层数据就是 <code>b</code>，修改 <code>b</code>，那么 <code>s</code> 就会被同步修改。循环中其实在不断的将需要拼接的单个字符串摆放在对应的位置</p>
<img src="demo.svg">


<p>实际上，根据不同的字符串拼接个数，定义了不同的函数，但是本质上都是调用上述函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring2</span><span class="params">(buf *tmpBuf, a [2]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring3</span><span class="params">(buf *tmpBuf, a [3]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring4</span><span class="params">(buf *tmpBuf, a [4]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring5</span><span class="params">(buf *tmpBuf, a [5]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试的时候发现，如果我们的拼接字符串个数在 <code>[2,5]</code> 范围内，那么我们会调用上述函数，然后再调用 <code>concatstrings</code>，如果超过这个值呢，会直接调用 <code>concatstrings</code> 进行处理。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>design</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串与切片转换</title>
    <url>/2021/06/27/golang/source-code/string-bytes/</url>
    <content><![CDATA[<p>本节内容主要代码位于 <code>runtime/string.go</code>， 基于 <code>go1.16.4/amd64</code></p>
<p>以下面的代码进行说明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">slice2str := <span class="type">string</span>(slice)</span><br><span class="line">str2slice := []<span class="type">byte</span>(slice2str)</span><br></pre></td></tr></table></figure>

<h2 id="slice-to-string"><a href="#slice-to-string" class="headerlink" title="slice to string"></a>slice to string</h2><p>底层将 <code>byte slice</code> 转换成 <code>string</code> 的函数为 <code>slicebytetostring</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, ptr *<span class="type">byte</span>, n <span class="type">int</span>)</span></span> (str <span class="type">string</span>) </span><br></pre></td></tr></table></figure>
<p>这个函数接收三个参数，<code>*tmpBuf</code> 是一个指向 <code>byte</code> 数组的指针，<code>ptr</code> 指向 <code>slice</code> 第一个元素的地址， <code>n</code> 表示切片的长度。</p>
<span id="more"></span>

<p>函数执行的时候，首先会判断字符串的长度 <code>n</code> 是否为0，如果为0的话，直接返回空字符串。</p>
<p>如果切片的长度为 <code>1</code> 的话，那么会直接从一个 <code>全局的静态表</code> 中取出对应的数据，并且获取到指向这个元素指针，然后通过字符串的底层结构 <code>stringStruct</code> 进行赋值即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		p := unsafe.Pointer(&amp;staticuint64s[*ptr])</span><br><span class="line">		<span class="keyword">if</span> sys.BigEndian &#123;</span><br><span class="line">			p = add(p, <span class="number">7</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		stringStructOf(&amp;str).str = p</span><br><span class="line">		stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>staticuint64s</code>，位于 <code>runtime/iface.go</code> 是一个静态数组，可以避免给一些比较小的整数值分配空间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> staticuint64s = [...]<span class="type">uint64</span>&#123;</span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>,</span><br><span class="line">	<span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x0b</span>, <span class="number">0x0c</span>, <span class="number">0x0d</span>, <span class="number">0x0e</span>, <span class="number">0x0f</span>,</span><br><span class="line">  .....</span><br><span class="line">	<span class="number">0xf0</span>, <span class="number">0xf1</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>,</span><br><span class="line">	<span class="number">0xf8</span>, <span class="number">0xf9</span>, <span class="number">0xfa</span>, <span class="number">0xfb</span>, <span class="number">0xfc</span>, <span class="number">0xfd</span>, <span class="number">0xfe</span>, <span class="number">0xff</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么我们可以知道，对于长度为1个且值相同的 <code>byte slice</code>，那么进行 <code>string</code> 转换的时候，对应的地址都是一样的，测试代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">test := []<span class="type">byte</span>&#123;<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">test2 := []<span class="type">byte</span>&#123;<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">a := <span class="type">string</span>(test)</span><br><span class="line">b := <span class="type">string</span>(test2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;a)).Data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>,(*reflect.StringHeader)(unsafe.Pointer(&amp;b)).Data)</span><br></pre></td></tr></table></figure>
<p>本地测试的时候输出均为 <code>3e0a08</code>，也就验证了我们的想法</p>
<p>如果切片的长度大于1，那么首先优先使用 <code>buf</code> 作为底层的数组，如果长度不够的话，则使用 <code>mallocgc</code> 分配大小为 <code>n</code> 的空间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; n &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">  p = unsafe.Pointer(buf)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  p = mallocgc(<span class="type">uintptr</span>(n), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配好空间之后，进行赋值操作，最后调用 <code>memmove </code>函数将 <code>ptr</code> 指向的n个字节的数据复制到申请的 <code>p</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stringStructOf(&amp;str).str = p</span><br><span class="line">stringStructOf(&amp;str).<span class="built_in">len</span> = n</span><br><span class="line">memmove(p, unsafe.Pointer(ptr), <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>
<p>所以主要的处理流程如下</p>
<img src="convert.svg">

<h2 id="string-to-slice"><a href="#string-to-slice" class="headerlink" title="string to slice"></a>string to slice</h2><p><code>stringtoslicebyte</code> 负责将 <code>string</code> 类型转换成 <code>byte slice</code> 类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="type">string</span>)</span></span> []<span class="type">byte</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>string</code> 的长度小于 <code>buf</code> 的长度，同时 <code>buf</code> 不为空，那么我们使用 <code>buf</code> 作为切片的存放空间，否则，我们需要调用 <code>rawbyteslice</code> 一块 <code>len(s)</code> 大小的 <code>byte</code> 切片大小空间，最后将s中的值复制到空间中返回这一块数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">  *buf = tmpBuf&#123;&#125;</span><br><span class="line">  b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(b, s)</span><br></pre></td></tr></table></figure>

<p><code>rawbyteslice</code> 其实也是调用 <code>mallocgc</code> 分配空间的，所以其实两者的转换在本质上都是申请一个空间，然后将数据拷贝一下，也没有什么特别神奇的地方，操作不同的具体原因就是 <code>byte slice</code> 和 <code>string</code> 类型的表示不太一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string的底层结构</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	str unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 底层结构</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将 <code>stringStruct</code> 转换成 <code>slice</code> 的时候，我们需要将 <code>str</code> 指向的数据拷贝到 <code>array</code> 中<br>当将 <code>slice</code> 转换成 <code>stringStruct</code> 的时候，我们需要将 <code>slice中array</code> 指向的数据拷贝到 <code>str</code> 中</p>
<img src="summary.svg">


<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>通过上面的分析，我们知道在进行 <code>byte slice</code> 和 <code>string</code> 的转换的时候是会需要进行复制的，这个代价很大，需要重新分配空间，那么如果业务中我们对于一个 <code>string</code> 或者 <code>byte slice</code> 只需要进行读取操作，不要进行修改数据，那么可以通过强转进行实现，下面对每种转换进行了基准测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkByte2String1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	bytes := []<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = <span class="type">string</span>(bytes)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkByte2String2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	bytes := []<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		(*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Data = (*reflect.SliceHeader)(unsafe.Pointer(&amp;bytes)).Data</span><br><span class="line">		(*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len = <span class="built_in">len</span>(bytes)</span><br><span class="line">		<span class="comment">// s = *(*string)(unsafe.Pointer(&amp;bytes)) // 也可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// b.Logf(&quot;%s&quot;, s)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkString2Byte1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = []<span class="type">byte</span>(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkString2Byte2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="keyword">var</span> bytes []<span class="type">byte</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		(*reflect.SliceHeader)(unsafe.Pointer(&amp;bytes)).Data = (*reflect.StringHeader)(unsafe.Pointer(&amp;str)).Data</span><br><span class="line">		(*reflect.SliceHeader)(unsafe.Pointer(&amp;bytes)).Len = <span class="built_in">len</span>(str)</span><br><span class="line">		(*reflect.SliceHeader)(unsafe.Pointer(&amp;bytes)).Cap = <span class="built_in">len</span>(str)</span><br><span class="line">		<span class="comment">// bytes = *(*[]byte)(unsafe.Pointer(&amp;str)) // 也可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// b.Logf(&quot;%s&quot;, bytes)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>go test -bench . convert_test.go</code> 结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz</span><br><span class="line">BenchmarkByte2String1-8         314203983                3.847 ns/op</span><br><span class="line">BenchmarkByte2String2-8         1000000000               0.2579 ns/op</span><br><span class="line">BenchmarkString2Byte1-8         225171763                5.340 ns/op</span><br><span class="line">BenchmarkString2Byte2-8         1000000000               0.2513 ns/op</span><br></pre></td></tr></table></figure>
<p>由此可见，使用底层进行转换能够提高<strong>10多倍</strong>性能，在不需要修改数据且对性能要求很高的情况下，可以考虑使用该种转换形式。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>design</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title>揭露切片的真实面目</title>
    <url>/2021/06/28/golang/source-code/slice/</url>
    <content><![CDATA[<p>本节主要内容位于 <code>runtime/slice.go</code>, 基于 <code>go1.16.4/amd64</code></p>
<p>创建一个切片十分简单，如下即可创建一个长度为 10 的 <code>int</code> 切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>但是具体是如何实现的呢，我们慢慢来看。</p>
<h2 id="slice-结构"><a href="#slice-结构" class="headerlink" title="slice 结构"></a>slice 结构</h2><p>在 <code>slice.go</code> 中首先定义的就是 <code>slice</code> 结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一看，其实 <code>slice</code> 也不是那么神奇，结构体中包含了一个指向实际数据的指针<code>array</code>，以及切片的长度 <code>len</code> 和切片的容量 <code>cap</code>。</p>
<p>切片作为参数进行传递的时候，传递的不是整个结构体，实际上是传入了 <code>slice</code> 中的 <code>array</code> 数据指针，如果在函数内部修改了切片，那么同样会修改外部的切片。</p>
<span id="more"></span>

<h2 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h2><p>对于切片的创建，我们可以使用 <code>make</code> 关键字，在声明长度的时候，也可以同时声明容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>当我们使用 make 创建一个新的切片的时候，系统会调用 <code>makeslice</code> 函数为我们创建一个切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer</span><br></pre></td></tr></table></figure>

<p>首先会计算需要分配的空间大小，如果分配的时候存在下面的任意一个问题，那么直接panic</p>
<ul>
<li>分配的空间大小溢出</li>
<li>分配的空间大小大于最大的分配大小 <code>maxAlloc</code></li>
<li>长度 <code>len</code> &lt; 0</li>
<li>长度 <code>len</code> 大于容量 <code>cap</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br></pre></td></tr></table></figure>
<p>然后最终调用 <code>mallocgc</code> 进行内存的分配</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mallocgc(mem, et, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mem</code> 表示分配的空间大小，<code>et</code> 表示分配的类型，不同的类型会有不同的字节大小，最后一个参数 <code>needzero=true</code> 表示需要将申请的空间数据清零，也就是相当于设置了零值</p>
<h2 id="append-扩容机制"><a href="#append-扩容机制" class="headerlink" title="append 扩容机制"></a>append 扩容机制</h2><p>当我们调用 <code>append</code> 往切片中添加元素的时候，如果切片的容量 <code>cap</code> 不够了，会触发一次扩容，调用底层的 <code>growslice</code> 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice</span><br></pre></td></tr></table></figure>
<p>当之前的容量小于 <code>1024</code>，那么会扩容的时候会容量会 <code>double</code>，如果否则的话，新的容量是原来的 <code>1.25</code> 倍</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">  newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">    newcap = doublecap</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">    <span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">      newcap += newcap / <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">    <span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">    <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确定了容量大小之后，会判断容量是否溢出或者大于最大的分配空间大小，如果满足分配条件，那么会调用 <code>mallocgc</code> 进行内存的分配，然后调用 <code>memmove</code> 将原来的数据复制到分配的空间中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">memmove(p, old.array, lenmem)</span><br></pre></td></tr></table></figure>
<p>最后返回一个新的切片，这个切片的数据和之前的数据是一样的，但是所在的空间不同，同时容量设置成新的数值 <code>newcap</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用下面的代码进行测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;没有扩容之前的slice地址:%p, 长度:%d, 容量:%d\n&quot;</span>, slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;扩容之后的slice地址:%p, 长度:%d, 容量:%d\n&quot;</span>, slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有扩容之前的slice地址:0xc0000121a0, 长度:4, 容量:4</span><br><span class="line">扩容之后的slice地址:0xc00000e340, 长度:5, 容量:8</span><br></pre></td></tr></table></figure>

<p>所以在我们使用一个切片的时候尤其要注意添加元素之后是否进行了扩容，如果进行了扩容，那么前后两个切片对应的完全不是同一个切片了，这也是 <code>growslice</code> 会返回一个 <code>slice</code> 类型的原因。如果有另一个变量引用了当前切片变量，当没有进行扩容的时候，这两个切片指向的是同一个地址，如果进行了扩容，那么两个切片指向的地址不同，对元素的修改对于另外一个切片不可见</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用修改</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// b 引用 a</span></span><br><span class="line">b := a   </span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v, b: %v\n&quot;</span>, a, b)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// a: [1 0], b: [1 0]</span></span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line"><span class="comment">// 扩容之后不可见</span></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v, b: %v\n&quot;</span>, a, b)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// a: [1 0], b: [1 10 1]</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>a，b</code> 指向的是 <code>同一块地址空间</code> ，所以修改 <code>b</code>，同时会影响 <code>a</code>。</p>
<p>在测试的时候有一个很有趣的想法，比如说下面的代码，输出的结果其实还是很简单的因为 <code>a</code> 的长度为 <code>1</code>，<code>b</code> 修改的索引在 <code>a</code> 中访问不到，所以输出为：<code>a: [0], b: [0 2]</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">b := a </span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v, b: %v\n&quot;</span>, a, b)</span><br></pre></td></tr></table></figure>
<p>这里之所以出现这种情况，因为 <code>b:=a</code> 的时候，执行的是值拷贝，<code>a,b</code> 两个指针也是一样的，指向同样的数据，其它的两个字段 <code>len, cap</code> 也是一样的值拷贝，但是这两个双方修改起来都是不可见的，它们的地址不同。</p>
<p>之所以上面的输出为 <code>a: [0], b: [0 2]</code>，并不是说 <code>a</code> 对应的数据空间中的数据没有修改，而只是字段长度 <code>len</code> 限制了访问的内存，那么我们有一个很自然的想法，修改 <code>a</code> 对应的长度，那么是不是就可以就可以访问到修改的区域数据，那么肯定要试试啊，使用 <code>unsafe</code> 包修改一下底层数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*reflect.SliceHeader)(unsafe.Pointer(&amp;a)).Len = <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v, b: %v\n&quot;</span>, a, b)</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，yeah，我们得到了想要的输出 <code>a: [0 2], b: [0 2]</code><br>当然，这些都是一些 <code>黑魔法</code>，平时不建议使用</p>
<h2 id="切片的复制"><a href="#切片的复制" class="headerlink" title="切片的复制"></a>切片的复制</h2><p>我们知道切片的传递类似于引用(准确的来说，Go中只有值传递，只不过传递的是指针，我们可以认为是引用传递)，所以在使用的时候我们不想修改原来切片中的数据，那么可以先使用 <code>copy</code> 复制一份，然后在新的切片中进行修改。</p>
<p>当我们调用 <code>copy</code> 的时候，底层一般情况下使用的是 <code>makeslicecopy</code> 函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslicecopy</span><span class="params">(et *_type, tolen <span class="type">int</span>, fromlen <span class="type">int</span>, from unsafe.Pointer)</span></span> unsafe.Pointer </span><br></pre></td></tr></table></figure>

<p>这个函数其实也很简单，主要分为三步：</p>
<p>1.计算需要分配的空间大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(tolen) &gt; <span class="type">uintptr</span>(fromlen) &#123;</span><br><span class="line">		<span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">		tomem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(tolen))</span><br><span class="line">		<span class="keyword">if</span> overflow || tomem &gt; maxAlloc || tolen &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		copymem = et.size * <span class="type">uintptr</span>(fromlen)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tomem = et.size * <span class="type">uintptr</span>(tolen)</span><br><span class="line">		copymem = tomem</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用 <code>mallocgc</code> 进行内存的数据分配</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> to unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		to = mallocgc(tomem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> copymem &lt; tomem &#123;</span><br><span class="line">			memclrNoHeapPointers(add(to, copymem), tomem-copymem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		to = mallocgc(tomem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> copymem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(to), <span class="type">uintptr</span>(from), copymem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.使用 <code>memmove</code> 复制原来的数据到新的内存空间中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">memmove(to, from, copymem)</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>从上面的分析我们知道，当使用 <code>append</code> 函数添加元素的时候，如果切片的容量 <code>cap</code> 不够，那么就需要进行扩容处理，期间会调用 <code>memmove</code> 进行一次拷贝，一定程度上会影响性能。如果我们知道确切的大小，使用下标进行赋值最理想，我们如果大概知道容量，那么可以采取预分配的方式，先分配一定大容量的切片，从而可以减少切片扩容的次数。</p>
<p>下面我们用实际的测试来说明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSlice1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++ &#123;</span><br><span class="line">		slice[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSlice2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++ &#123;</span><br><span class="line">		slice = <span class="built_in">append</span>(slice, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSlice3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++ &#123;</span><br><span class="line">		slice = <span class="built_in">append</span>(slice, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMakeSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">&quot;下标&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">			makeSlice1()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	b.Run(<span class="string">&quot;原始&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">			makeSlice2()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	b.Run(<span class="string">&quot;预分配&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">			makeSlice3()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行基准测试，我们可以得到下面的结果，很明显可以看出性能差异来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz</span><br><span class="line">BenchmarkMakeSlice/下标-8                3401653               668.9 ns/op</span><br><span class="line">BenchmarkMakeSlice/原始-8                 127171              8066 ns/op</span><br><span class="line">BenchmarkMakeSlice/预分配-8               704804              1620 ns/op</span><br></pre></td></tr></table></figure>
<p>所以在业务中，选择 <code>下标 &gt; 预分配容量大小 &gt; 0容量</code></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>design</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin 快速上手</title>
    <url>/2021/07/22/golang/framework/gin/basic/</url>
    <content><![CDATA[<p>使用 Go 搭建 Web 后端，最简单的就是使用原生的 <code>net/http</code> 库了，下面是一个简单的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(w, <span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, greet)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码之后，便会在8080端口处监听，接收客户端的请求，然后返回响应，访问 <code>http://localhost:8080</code> 即可以访问到对应的内容。</p>
<span id="more"></span>

<p>对于简单的服务器，使用标准库提供的函数就已经可以解决了，如果更加复杂一点，使用标准库处理就显得力不从心了，这时候我们可以使用网上提供的框架，比如 <code>Gin</code>。</p>
<p><code>Gin</code> 使用起来特别方便(真的很方便！)，并且支持中间件，异常处理，路由组等等，下面用代码演示一下如何使用吧。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>首先我们需要下载gin，我们要保证设置了 <code>GO111MODULE=on</code>，然后进行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init gin-demo</span><br><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<p>下面是一个简单的web服务，我们使用 <code>gin.Default()</code> 创建一个默认的路由引擎,然后使用 <code>GET</code> 方式注册一个路由，负责接受来自客户端的 <code>GET</code> 请求，并且返回一个 <code>JSON</code> 数据给客户端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() <span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用curl进行测试结果如下，符合预期</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8080/ping </span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;pong&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用HTTP方法"><a href="#使用HTTP方法" class="headerlink" title="使用HTTP方法"></a>使用HTTP方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认中间件（logger 和 recovery 中间件）创建 gin 路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/someGet&quot;</span>, getting)</span><br><span class="line">router.POST(<span class="string">&quot;/somePost&quot;</span>, posting)</span><br><span class="line">router.PUT(<span class="string">&quot;/somePut&quot;</span>, putting)</span><br><span class="line">router.DELETE(<span class="string">&quot;/someDelete&quot;</span>, deleting)</span><br><span class="line">router.PATCH(<span class="string">&quot;/somePatch&quot;</span>, patching)</span><br><span class="line">router.HEAD(<span class="string">&quot;/someHead&quot;</span>, head)</span><br><span class="line">router.OPTIONS(<span class="string">&quot;/someOptions&quot;</span>, options)</span><br></pre></td></tr></table></figure>

<h3 id="使用路由组"><a href="#使用路由组" class="headerlink" title="使用路由组"></a>使用路由组</h3><p>使用 <code>Group</code> 方法进行创建，路由组可以使得路由结构更加清晰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的路由组: v1</span></span><br><span class="line">v1 := router.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  v1.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">  v1.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">  v1.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回内容"><a href="#返回内容" class="headerlink" title="返回内容"></a>返回内容</h3><h4 id="返回JSON内容"><a href="#返回JSON内容" class="headerlink" title="返回JSON内容"></a>返回JSON内容</h4><p><code>gin.Context</code> 提供了 <code>JSON</code> 方法， 我们可以直接使用， 第一个参数为返回的状态码，第二个参数为返回的数据，<code>gin.H</code> 其实就是 <code>map[string]interface&#123;&#125;</code> 的简写，最后会被序列化返回给客户端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router := gin.Default()</span><br><span class="line">router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="返回HTML内容"><a href="#返回HTML内容" class="headerlink" title="返回HTML内容"></a>返回HTML内容</h4><p>首先需要加载 <code>HTML</code> 模板文件，然后使用 <code>c.HTML</code> 方法将数据注入到指定的模板文件中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router := gin.Default()</span><br><span class="line">router.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line">router.GET(<span class="string">&quot;/posts/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.HTML(http.StatusOK, <span class="string">&quot;posts/index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Posts&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>模板文件 <code>posts/index.tmpl</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; define &quot;posts/index.tmpl&quot; &#125;&#125;</span><br><span class="line">&lt;html&gt;&lt;h1&gt;</span><br><span class="line">	&#123;&#123; .title &#125;&#125;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;Using posts/index.tmpl&lt;/p&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h4><p>String方法即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;String&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.String(http.StatusOK, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="获取查询参数"><a href="#获取查询参数" class="headerlink" title="获取查询参数"></a>获取查询参数</h3><p>对于简单的 <code>query</code> 参数，使用 <code>GetQuery</code> 和 <code>DefaultQuery</code> 方法就好了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/query&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  q, exist := c.GetQuery(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> exist &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;data&quot;</span>: q,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;code&quot;</span>:    <span class="number">400</span>,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;q is not exist&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8080/query</span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:400,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;q is not exist&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">$ curl http://localhost:8080/query?q=hello</span><br><span class="line">&#123;<span class="string">&quot;data&quot;</span>:<span class="string">&quot;hello&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>不过如果需要获取到的 <code>query</code> 参数是数组或者 map，那么就需要使用其他的方式了，比如数组需要使用<code>GetQueryArray</code> or <code>QueryArray</code> 和 <code>GetQueryMap</code> or <code>QueryMap</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/query_array&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  q, exist := c.GetQueryArray(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> exist &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;data&quot;</span>: q,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;code&quot;</span>:    <span class="number">400</span>,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;q is not exist&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/query_map&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  q, exist := c.GetQueryMap(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> exist &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;data&quot;</span>: q,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;code&quot;</span>:    <span class="number">400</span>,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;q is not exist&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&quot;http://localhost:8080/query_array?q=1&amp;q=2&quot;</span></span><br><span class="line">&#123;<span class="string">&quot;data&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">$ curl <span class="string">&quot;http://localhost:8080/query_map?q[1]=1&amp;q[2]=2&quot;</span></span><br><span class="line">&#123;<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;1&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取表单内容"><a href="#获取表单内容" class="headerlink" title="获取表单内容"></a>获取表单内容</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.POST(<span class="string">&quot;/form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  name := c.PostForm(<span class="string">&quot;name&quot;</span>)  <span class="comment">// or GetPostForm</span></span><br><span class="line">  list := c.PostFormArray(<span class="string">&quot;list&quot;</span>) <span class="comment">// or GetPostFormArray</span></span><br><span class="line">  m := c.PostFormMap(<span class="string">&quot;map&quot;</span>)  <span class="comment">// or GetPostFormMap</span></span><br><span class="line">  c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: list, </span><br><span class="line">    <span class="string">&quot;map&quot;</span>: m,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl  --form name=<span class="built_in">test</span> --form list=1 --form list=2 --form map[1]=1 --form map[2]=2 http://localhost:8080/form</span><br><span class="line">&#123;<span class="string">&quot;list&quot;</span>:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>],<span class="string">&quot;map&quot;</span>:&#123;<span class="string">&quot;1&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;test&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span></span><br><span class="line">router.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br><span class="line">r.POST(<span class="string">&quot;/upload/single&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 单文件</span></span><br><span class="line">    file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    fmt.Println(file.Filename)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 上传文件至指定目录</span></span><br><span class="line">    c.SaveUploadedFile(file, dst)</span><br><span class="line">  </span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;upload success&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.POST(<span class="string">&quot;/upload/multiple&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Multipart form</span></span><br><span class="line">  form, _ := c.MultipartForm()</span><br><span class="line">  files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传文件至指定目录</span></span><br><span class="line">    c.SaveUploadedFile(file, dst)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h3><p>中间件可以对经过一个路由的请求进行预处理，比如说鉴权，记录日志等等, <code>gin</code> 中创建一个中间件十分简单，我们只需要返回一个 <code>gin.Handler</code> 的类型就好了。下面就创建了一个简单的中间件来计算路由花费的时间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cost</span><span class="params">()</span></span> gin.HandlerFunc&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// 一定要调用</span></span><br><span class="line">		c.Next()</span><br><span class="line">		fmt.Println(<span class="string">&quot;total time: &quot;</span>, time.Now().Sub(start))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用中间件有多种方式，一种是全局中间件，一种是路由组中间件，一种单个路由中间件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router := gin.New() <span class="comment">// 没有使用任何中间件的路由引擎</span></span><br><span class="line"><span class="comment">// 整个路由</span></span><br><span class="line">router.Use(Cost())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由组</span></span><br><span class="line">group := r.Group(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">group.Use(Cost())</span><br><span class="line">&#123;</span><br><span class="line">  group.GET(<span class="string">&quot;/greet&quot;</span>, greet)</span><br><span class="line">  group.POST(<span class="string">&quot;/form&quot;</span>, form)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单个路由，不会影响其他路由</span></span><br><span class="line">router.POST(<span class="string">&quot;/middleware&quot;</span>, Cost(), controller)</span><br></pre></td></tr></table></figure>

<h3 id="绑定参数至结构体"><a href="#绑定参数至结构体" class="headerlink" title="绑定参数至结构体"></a>绑定参数至结构体</h3><p>在业务中，我们经常需要将用户发送过来的请求绑定到一个特定的结构体中，这样使用起来更加方便，<code>gin</code> 提供了大量的绑定方法，下面以 <code>ShouldBind</code> 为例讲解如何使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先声明需要绑定参数的结构体</span></span><br><span class="line"><span class="keyword">type</span> LoginReq <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// form 参数指定需要绑定的表单内容</span></span><br><span class="line">  <span class="comment">// binding:&quot;required&quot; 表示不能非空，否则绑定的时候返回错误</span></span><br><span class="line">  <span class="comment">// 如果该字段非必须，可以去掉该tag</span></span><br><span class="line">  Username <span class="type">string</span> <span class="string">`form:&quot;username&quot; json:&quot;username&quot;  binding:&quot;required&quot;`</span></span><br><span class="line">  Password <span class="type">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> form LoginReq</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := c.ShouldBind(&amp;form); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;code&quot;</span>:    <span class="number">-1</span>,</span><br><span class="line">      <span class="string">&quot;message&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, form)</span><br><span class="line">  c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>:    <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: form,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>gin</code> 还有很多方面的特性，这里只是简单的介绍了如何去使用，更多的使用方法可以参考<a href="https://gin-gonic.com/docs/">文档</a>，个人之前也用过写了一个<a href="https://github.com/junhaideng/Golang-BBS">小项目</a>。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>framework</tag>
        <tag>Gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 代码测试覆盖度</title>
    <url>/2022/04/10/golang/fundamental/test/cover/</url>
    <content><![CDATA[<p>在 Go 语言中，本身提供了一些命令来展示代码的覆盖度，我们可以通过执行这些命令来查看哪些语句被测试覆盖到了，哪些没有，进而可以编写更多的 case 来提高代码的覆盖度。</p>
<p>执行下面的命令，可以得出项目里面所有 package 的覆盖度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> ./... -cover</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?       github.com/junhaideng/sphincs/api       [no test files]</span><br><span class="line">?       github.com/junhaideng/sphincs/cmd       [no test files]</span><br><span class="line">ok      github.com/junhaideng/sphincs/common    0.462s  coverage: 51.9% of statements</span><br><span class="line">?       github.com/junhaideng/sphincs/hash      [no test files]</span><br><span class="line">ok      github.com/junhaideng/sphincs/merkle    0.467s  coverage: 68.2% of statements</span><br><span class="line">?       github.com/junhaideng/sphincs/rand      [no test files]</span><br><span class="line">ok      github.com/junhaideng/sphincs/signature 1.367s  coverage: 92.3% of statements</span><br></pre></td></tr></table></figure>

<p>如果说我们想要单独看一个 package 中测试 case 所达到的覆盖度，可以指定包的名称</p>
<blockquote>
<p>设置 -count=1 可以避免代码没修改导致的缓存，通俗来讲就是重新跑一遍</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span>  github.com/junhaideng/sphincs/signature -cover -count=1</span><br></pre></td></tr></table></figure>

<p>如果想要查看哪些具体行被覆盖了，可以设置 <code>-coverprofile</code> 参数，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span>  github.com/junhaideng/sphincs/signature -cover -count=1  -coverprofile=<span class="string">&quot;cover.out&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后将输出的文件转换成 html 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool cover -html=<span class="string">&quot;cover.out&quot;</span> -o cover.html</span><br></pre></td></tr></table></figure>
<p>使用浏览器打开 html 文件，可以显示到那些代码行被覆盖了，哪些没有，这里的红色的表示测试没有覆盖到，绿色表示覆盖到了，灰色表示不用计算的行</p>
<img src="cover-html.png" width=300>

<br/>

<p><strong>提高代码的测试覆盖度有利于发现问题所在，但是一味的追求测试覆盖率会花费更多的时间，得不偿失。</strong></p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>fundamental</tag>
        <tag>testing</tag>
      </tags>
  </entry>
</search>
